using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace SourceGenerators
{
	[Generator]
	public class ToExprGenerator : ISourceGenerator
	{
		public void Initialize(GeneratorInitializationContext context)
		{
#if DEBUG1
			if (!Debugger.IsAttached)
			{
				Debugger.Launch();
			}
#endif

			context.RegisterForPostInitialization(i => i.AddSource("ToExprAttribute.g.cs",
				"""
				// <auto-generated/>
				#pragma warning disable
				#nullable enable annotations

				using System;

				namespace Linq.Expressions.Deconstruct
				{
					[AttributeUsage(AttributeTargets.Field, Inherited = false, AllowMultiple = false)]
					[System.Diagnostics.Conditional("ToExprGenerator_DEBUG")]
					sealed class ToExprAttribute : Attribute
					{
						public string PropertyName { get; set; }
						public bool   IsNullable   { get; set; }
					}
				}

				"""));

			context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
		}

		public void Execute(GeneratorExecutionContext context)
		{
			if (context.SyntaxContextReceiver is not SyntaxReceiver receiver)
				return;

			var attributeSymbol = context.Compilation.GetTypeByMetadataName("Linq.Expressions.Deconstruct.ToExprAttribute");

			foreach (var group in receiver.Fields.GroupBy<IFieldSymbol,INamedTypeSymbol>(f => f.ContainingType, SymbolEqualityComparer.Default))
			{
				var classSource = ProcessClass(group.Key, group.ToList(), attributeSymbol, context);
				context.AddSource($"{group.Key.Name}.ToExpr.g.cs", classSource);
			}
		}

		string ProcessClass(INamedTypeSymbol classSymbol, List<IFieldSymbol> fields, ISymbol attributeSymbol, GeneratorExecutionContext context)
		{
//			if (!classSymbol.ContainingSymbol.Equals(classSymbol.ContainingNamespace, SymbolEqualityComparer.Default))
//			{
//				return null; //TODO: issue a diagnostic that it must be top level
//			}

			var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();

			var source = new StringBuilder(
				$$"""
				// <auto-generated/>
				#pragma warning disable
				#nullable enable annotations

				using System;

				#nullable enable

				namespace {{namespaceName}}
				{
					partial class Expr
					{
						partial class {{classSymbol.Name}}
						{

				""");

			foreach (var fieldSymbol in fields)
				ProcessField(source, classSymbol, fieldSymbol, attributeSymbol);

			source
				.AppendLine("		}")
				.AppendLine("	}")
				.AppendLine("}")
				;

			return source.ToString();
		}

		void ProcessField(StringBuilder source, INamedTypeSymbol classSymbol, IFieldSymbol fieldSymbol, ISymbol attributeSymbol)
		{
			var fieldName = fieldSymbol.Name;
			var fieldType = fieldSymbol.Type.ToDisplayString();

			var attributeData = fieldSymbol.GetAttributes().Single(ad => ad.AttributeClass!.Equals(attributeSymbol, SymbolEqualityComparer.Default));
			var overridenName = attributeData.NamedArguments.SingleOrDefault(kvp => kvp.Key == "PropertyName").Value;
			var isNullable    = attributeData.NamedArguments.SingleOrDefault(kvp => kvp.Key == "IsNullable").  Value;

			string propertyName;

			if (overridenName.IsNull)
			{
				propertyName = fieldName.TrimStart('_');

				if (propertyName.Length > 0)
					propertyName = char.ToUpper(propertyName[0]) + propertyName[1..];
			}
			else
			{
				propertyName = overridenName.Value!.ToString();
			}

			if (propertyName.Length == 0 || propertyName == fieldName || classSymbol.MemberNames.Contains(propertyName))
			{
				if (fieldSymbol.Locations[0] is { Kind: LocationKind.SourceFile  } location)
				{
					var ls = location.GetMappedLineSpan();
					source
						.AppendLine($"#line ({ls.Span.Start.Line + 1},{ls.Span.Start.Character})-({ls.Span.End.Line + 1},{ls.Span.End.Character}) \"{ls.Path}\"")
						;
				}

				source
					.AppendLine($"#error Generator failed on '{fieldName}'.")
					.AppendLine("#line default")
					;
				return;
			}

			if (isNullable.IsNull || isNullable.Value is false)
				fieldType = fieldType.TrimEnd('?');

			source.Append(
				$"""
							public {fieldType} {propertyName} => {fieldName} ??= Expr.{propertyName}.ToExpr();

				""");
		}

		public class SyntaxReceiver : ISyntaxContextReceiver
		{
			public List<IFieldSymbol> Fields { get; } = new ();

			public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
			{
				if (context.Node is FieldDeclarationSyntax { AttributeLists: [_, ..] } field)
				{
					foreach (var variable in field.Declaration.Variables)
					{
						var fieldSymbol = context.SemanticModel.GetDeclaredSymbol(variable) as IFieldSymbol;
						var attributes  = fieldSymbol!.GetAttributes();

						if (attributes.Any(ad => ad.AttributeClass!.ToDisplayString() == "Linq.Expressions.Deconstruct.ToExprAttribute"))
							Fields.Add(fieldSymbol);
					}
				}
			}
		}
	}
}
