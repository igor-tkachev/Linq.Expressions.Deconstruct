using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;


namespace SourceGenerators
{
	[Generator]
	public class ToExprGenerator : IIncrementalGenerator
	{
		public void Initialize(IncrementalGeneratorInitializationContext context)
		{
	#if DEBUG1
			if (!Debugger.IsAttached)
			{
				Debugger.Launch();
			}
	#endif

			// Generate the attribute definition
			context.RegisterPostInitializationOutput(ctx =>
			{
				ctx.AddSource("ToExprAttribute.g.cs",
					"""
					// <auto-generated/>
					#pragma warning disable
					#nullable enable annotations

					using System;

					namespace Linq.Expressions.Deconstruct
					{
						[AttributeUsage(AttributeTargets.Field, Inherited = false, AllowMultiple = false)]
						[System.Diagnostics.Conditional("ToExprGenerator_DEBUG")]
						sealed class ToExprAttribute : Attribute
						{
							public string PropertyName { get; set; }
							public bool   IsNullable   { get; set; }
						}
					}
					""");
			});

			// Collect all fields with the target attribute
			//
			var fieldsWithAttribute = context.SyntaxProvider
				.CreateSyntaxProvider(
					static (node, _) => node is FieldDeclarationSyntax { AttributeLists.Count: > 0 },
					static (ctx,  _) => GetFieldSymbolWithAttribute(ctx))
				.Where(static field => field is not null)
				.Select(static (field, _) => field!)
				.Collect();

			// Main code generation step
			//
			context.RegisterSourceOutput(fieldsWithAttribute, (spc, fields) =>
			{
				var grouped = fields.GroupBy(f => f.ContainingType, SymbolEqualityComparer.Default);

				foreach (var group in grouped)
				{
					var classSource = ProcessClass((INamedTypeSymbol)group.Key!, group.ToList(), spc);
					spc.AddSource($"{group.Key!.Name}.ToExpr.g.cs", SourceText.From(classSource, Encoding.UTF8));
				}
			});
		}

		static IFieldSymbol? GetFieldSymbolWithAttribute(GeneratorSyntaxContext context)
		{
			if (context.Node is not FieldDeclarationSyntax fieldDeclaration)
				return null;

			foreach (var variable in fieldDeclaration.Declaration.Variables)
			{
				if (context.SemanticModel.GetDeclaredSymbol(variable) is not IFieldSymbol symbol)
					continue;

				if (symbol.GetAttributes().Any(attr => attr.AttributeClass?.ToDisplayString() == "Linq.Expressions.Deconstruct.ToExprAttribute"))
					return symbol;
			}

			return null;
		}

		static string ProcessClass(INamedTypeSymbol classSymbol, List<IFieldSymbol> fields, SourceProductionContext context)
		{
//			if (!classSymbol.ContainingSymbol.Equals(classSymbol.ContainingNamespace, SymbolEqualityComparer.Default))
//			{
//				return null; //TODO: issue a diagnostic that it must be top level
//			}

			var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();

			var source = new StringBuilder(
				$$"""
				// <auto-generated/>
				#pragma warning disable
				#nullable enable annotations

				using System;

				namespace {{namespaceName}}
				{
					partial class Expr
					{
						partial class {{classSymbol.Name}}
						{

				""");

			var attributeSymbol = fields[0].GetAttributes().First(a => a.AttributeClass?.Name == "ToExprAttribute").AttributeClass!;

			foreach (var fieldSymbol in fields)
				ProcessField(source, classSymbol, fieldSymbol, attributeSymbol);

			source
				.AppendLine("		}")
				.AppendLine("	}")
				.AppendLine("}")
				;

			return source.ToString();
		}

		static void ProcessField(StringBuilder source, INamedTypeSymbol classSymbol, IFieldSymbol fieldSymbol, INamedTypeSymbol attributeSymbol)
		{
			var fieldName = fieldSymbol.Name;
			var fieldType = fieldSymbol.Type.ToDisplayString();

			var attributeData  = fieldSymbol.GetAttributes().Single(ad => SymbolEqualityComparer.Default.Equals(ad.AttributeClass, attributeSymbol));
			var overriddenName = attributeData.NamedArguments.FirstOrDefault(kvp => kvp.Key == "PropertyName").Value;
			var isNullable     = attributeData.NamedArguments.FirstOrDefault(kvp => kvp.Key == "IsNullable").Value;

			string propertyName;

			if (overriddenName.IsNull)
			{
				propertyName = fieldName.TrimStart('_');

				if (propertyName.Length > 0)
					propertyName = char.ToUpper(propertyName[0]) + propertyName[1..];
			}
			else
			{
				propertyName = overriddenName.Value?.ToString() ?? "";
			}

			// Skip if name is invalid or clashes with other members
			//
			if (propertyName.Length == 0 || propertyName == fieldName || classSymbol.MemberNames.Contains(propertyName))
			{
				if (fieldSymbol.Locations[0] is { Kind: LocationKind.SourceFile  } location)
				{
					var ls = location.GetLineSpan();
					source.AppendLine($"#line ({ls.StartLinePosition.Line + 1},{ls.StartLinePosition.Character})-({ls.EndLinePosition.Line + 1},{ls.EndLinePosition.Character}) \"{ls.Path}\"");
				}

				source
					.AppendLine($"#error Generator failed on '{fieldName}'.")
					.AppendLine("#line default")
					;

				return;
			}

			// If IsNullable is false or unset, trim the trailing '?'
			//
			if (isNullable.IsNull || isNullable.Value is false)
				fieldType = fieldType.TrimEnd('?');

			source.Append(
				$"""
							public {fieldType} {propertyName} => {fieldName} ??= Expr.{propertyName}.ToExpr();

				""");
		}
	}
}
