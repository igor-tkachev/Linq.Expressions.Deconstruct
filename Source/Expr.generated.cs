//---------------------------------------------------------------------------------------------------
// <auto-generated>
//    This code was generated by T4 template.
//    Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>
//---------------------------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq.Expressions;
using System.Reflection;

#nullable enable

namespace Linq.Expressions.Deconstruct
{
	public abstract partial class Expr
	{
		#region Call

		public partial class Call : Expr
		{
			public MethodCallExpression Expr { get; }

			public Call(MethodCallExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?(Call? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator MethodCallExpression?(Call? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Call?(MethodCallExpression? expr) => expr == null ? null : new Call(expr);
		}

		#endregion

		#region Conditional

		public partial class Conditional : Expr
		{
			public ConditionalExpression Expr { get; }

			public Conditional(ConditionalExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?(Conditional? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator ConditionalExpression?(Conditional? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Conditional?(ConditionalExpression? expr) => expr == null ? null : new Conditional(expr);
		}

		#endregion

		#region Invoke

		public partial class Invoke : Expr
		{
			public InvocationExpression Expr { get; }

			public Invoke(InvocationExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?(Invoke? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator InvocationExpression?(Invoke? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Invoke?(InvocationExpression? expr) => expr == null ? null : new Invoke(expr);
		}

		#endregion

		#region Lambda

		public partial class Lambda : Expr
		{
			public LambdaExpression Expr { get; }

			public Lambda(LambdaExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?(Lambda? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator LambdaExpression?(Lambda? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Lambda?(LambdaExpression? expr) => expr == null ? null : new Lambda(expr);
		}

		#endregion

		#region ListInit

		public partial class ListInit : Expr
		{
			public ListInitExpression Expr { get; }

			public ListInit(ListInitExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?(ListInit? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator ListInitExpression?(ListInit? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator ListInit?(ListInitExpression? expr) => expr == null ? null : new ListInit(expr);
		}

		#endregion

		#region Member

		public partial class Member : Expr
		{
			public MemberExpression Expr { get; }

			public Member(MemberExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?(Member? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator MemberExpression?(Member? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Member?(MemberExpression? expr) => expr == null ? null : new Member(expr);
		}

		#endregion

		#region MemberInit

		public partial class MemberInit : Expr
		{
			public MemberInitExpression Expr { get; }

			public MemberInit(MemberInitExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?(MemberInit? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator MemberInitExpression?(MemberInit? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator MemberInit?(MemberInitExpression? expr) => expr == null ? null : new MemberInit(expr);
		}

		#endregion

		#region New

		public partial class New : Expr
		{
			public NewExpression Expr { get; }

			public New(NewExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?(New? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator NewExpression?(New? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator New?(NewExpression? expr) => expr == null ? null : new New(expr);
		}

		#endregion

		#region NewArrayBounds

		public partial class NewArrayBounds : Expr
		{
			public NewArrayExpression Expr { get; }

			public NewArrayBounds(NewArrayExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?(NewArrayBounds? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator NewArrayExpression?(NewArrayBounds? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator NewArrayBounds?(NewArrayExpression? expr) => expr == null ? null : new NewArrayBounds(expr);
		}

		#endregion

		#region NewArrayInit

		public partial class NewArrayInit : Expr
		{
			public NewArrayExpression Expr { get; }

			public NewArrayInit(NewArrayExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?(NewArrayInit? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator NewArrayExpression?(NewArrayInit? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator NewArrayInit?(NewArrayExpression? expr) => expr == null ? null : new NewArrayInit(expr);
		}

		#endregion

		#region TypeEqual

		public partial class TypeEqual : Expr
		{
			public TypeBinaryExpression Expr { get; }

			public TypeEqual(TypeBinaryExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?(TypeEqual? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator TypeBinaryExpression?(TypeEqual? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator TypeEqual?(TypeBinaryExpression? expr) => expr == null ? null : new TypeEqual(expr);
		}

		#endregion

		#region TypeIs

		public partial class TypeIs : Expr
		{
			public TypeBinaryExpression Expr { get; }

			public TypeIs(TypeBinaryExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?(TypeIs? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator TypeBinaryExpression?(TypeIs? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator TypeIs?(TypeBinaryExpression? expr) => expr == null ? null : new TypeIs(expr);
		}

		#endregion

		#region Block

		public partial class Block : Expr
		{
			public BlockExpression Expr { get; }

			public Block(BlockExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?(Block? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator BlockExpression?(Block? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Block?(BlockExpression? expr) => expr == null ? null : new Block(expr);
		}

		#endregion

		#region Dynamic

		public partial class Dynamic : Expr
		{
			public DynamicExpression Expr { get; }

			public Dynamic(DynamicExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?(Dynamic? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator DynamicExpression?(Dynamic? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Dynamic?(DynamicExpression? expr) => expr == null ? null : new Dynamic(expr);
		}

		#endregion

		#region Goto

		public partial class Goto : Expr
		{
			public GotoExpression Expr { get; }

			public Goto(GotoExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?(Goto? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator GotoExpression?(Goto? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Goto?(GotoExpression? expr) => expr == null ? null : new Goto(expr);
		}

		#endregion

		#region Index

		public partial class Index : Expr
		{
			public IndexExpression Expr { get; }

			public Index(IndexExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?(Index? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator IndexExpression?(Index? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Index?(IndexExpression? expr) => expr == null ? null : new Index(expr);
		}

		#endregion

		#region Label

		public partial class Label : Expr
		{
			public LabelExpression Expr { get; }

			public Label(LabelExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?(Label? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator LabelExpression?(Label? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Label?(LabelExpression? expr) => expr == null ? null : new Label(expr);
		}

		#endregion

		#region RuntimeVariables

		public partial class RuntimeVariables : Expr
		{
			public RuntimeVariablesExpression Expr { get; }

			public RuntimeVariables(RuntimeVariablesExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?(RuntimeVariables? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator RuntimeVariablesExpression?(RuntimeVariables? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator RuntimeVariables?(RuntimeVariablesExpression? expr) => expr == null ? null : new RuntimeVariables(expr);
		}

		#endregion

		#region Loop

		public partial class Loop : Expr
		{
			public LoopExpression Expr { get; }

			public Loop(LoopExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?(Loop? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator LoopExpression?(Loop? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Loop?(LoopExpression? expr) => expr == null ? null : new Loop(expr);
		}

		#endregion

		#region Switch

		public partial class Switch : Expr
		{
			public SwitchExpression Expr { get; }

			public Switch(SwitchExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?(Switch? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator SwitchExpression?(Switch? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Switch?(SwitchExpression? expr) => expr == null ? null : new Switch(expr);
		}

		#endregion

		#region Try

		public partial class Try : Expr
		{
			public TryExpression Expr { get; }

			public Try(TryExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?(Try? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator TryExpression?(Try? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Try?(TryExpression? expr) => expr == null ? null : new Try(expr);
		}

		#endregion

		#region Extension

		public partial class Extension : Expr
		{
			public Expression Expr { get; }

			public Extension(Expression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?(Extension? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Extension?(Expression? expr) => expr == null ? null : new Extension(expr);
		}

		#endregion

		#region DebugInfo

		public partial class DebugInfo : Expr
		{
			public DebugInfoExpression Expr { get; }

			public DebugInfo(DebugInfoExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?(DebugInfo? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator DebugInfoExpression?(DebugInfo? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator DebugInfo?(DebugInfoExpression? expr) => expr == null ? null : new DebugInfo(expr);
		}

		#endregion

		#region Parameter

		public partial class Parameter : Expr
		{
			public ParameterExpression Expr { get; }

			public Parameter(ParameterExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?(Parameter? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator ParameterExpression?(Parameter? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Parameter?(ParameterExpression? expr) => expr == null ? null : new Parameter(expr);
		}

		#endregion

		#region Constant

		public partial class Constant : Expr
		{
			public ConstantExpression Expr { get; }

			public Constant(ConstantExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?(Constant? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator ConstantExpression?(Constant? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Constant?(ConstantExpression? expr) => expr == null ? null : new Constant(expr);
		}

		#endregion

		#region Default

		public partial class Default : Expr
		{
			public DefaultExpression Expr { get; }

			public Default(DefaultExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?(Default? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator DefaultExpression?(Default? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Default?(DefaultExpression? expr) => expr == null ? null : new Default(expr);
		}

		#endregion

		#region Add

		public class Add : Expr
		{
			public BinaryExpression Expr { get; }

			public Add(BinaryExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?      (Add? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator BinaryExpression?(Add? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Add?(BinaryExpression? expr) => expr == null ? null : new Add(expr);

			public void Deconstruct(out Type type, out Expr left, out Expr right)
			{
				type  = Expr.Type;
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}

			public void Deconstruct(out Expr left, out Expr right)
			{
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}
		}

		#endregion

		#region AddChecked

		public class AddChecked : Expr
		{
			public BinaryExpression Expr { get; }

			public AddChecked(BinaryExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?      (AddChecked? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator BinaryExpression?(AddChecked? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator AddChecked?(BinaryExpression? expr) => expr == null ? null : new AddChecked(expr);

			public void Deconstruct(out Type type, out Expr left, out Expr right)
			{
				type  = Expr.Type;
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}

			public void Deconstruct(out Expr left, out Expr right)
			{
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}
		}

		#endregion

		#region And

		public class And : Expr
		{
			public BinaryExpression Expr { get; }

			public And(BinaryExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?      (And? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator BinaryExpression?(And? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator And?(BinaryExpression? expr) => expr == null ? null : new And(expr);

			public void Deconstruct(out Type type, out Expr left, out Expr right)
			{
				type  = Expr.Type;
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}

			public void Deconstruct(out Expr left, out Expr right)
			{
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}
		}

		#endregion

		#region AndAlso

		public class AndAlso : Expr
		{
			public BinaryExpression Expr { get; }

			public AndAlso(BinaryExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?      (AndAlso? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator BinaryExpression?(AndAlso? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator AndAlso?(BinaryExpression? expr) => expr == null ? null : new AndAlso(expr);

			public void Deconstruct(out Type type, out Expr left, out Expr right)
			{
				type  = Expr.Type;
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}

			public void Deconstruct(out Expr left, out Expr right)
			{
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}
		}

		#endregion

		#region ArrayIndex

		public class ArrayIndex : Expr
		{
			public BinaryExpression Expr { get; }

			public ArrayIndex(BinaryExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?      (ArrayIndex? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator BinaryExpression?(ArrayIndex? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator ArrayIndex?(BinaryExpression? expr) => expr == null ? null : new ArrayIndex(expr);

			public void Deconstruct(out Type type, out Expr left, out Expr right)
			{
				type  = Expr.Type;
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}

			public void Deconstruct(out Expr left, out Expr right)
			{
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}
		}

		#endregion

		#region Assign

		public class Assign : Expr
		{
			public BinaryExpression Expr { get; }

			public Assign(BinaryExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?      (Assign? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator BinaryExpression?(Assign? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Assign?(BinaryExpression? expr) => expr == null ? null : new Assign(expr);

			public void Deconstruct(out Type type, out Expr left, out Expr right)
			{
				type  = Expr.Type;
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}

			public void Deconstruct(out Expr left, out Expr right)
			{
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}
		}

		#endregion

		#region Coalesce

		public class Coalesce : Expr
		{
			public BinaryExpression Expr { get; }

			public Coalesce(BinaryExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?      (Coalesce? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator BinaryExpression?(Coalesce? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Coalesce?(BinaryExpression? expr) => expr == null ? null : new Coalesce(expr);

			public void Deconstruct(out Type type, out Expr left, out Expr right)
			{
				type  = Expr.Type;
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}

			public void Deconstruct(out Expr left, out Expr right)
			{
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}
		}

		#endregion

		#region Divide

		public class Divide : Expr
		{
			public BinaryExpression Expr { get; }

			public Divide(BinaryExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?      (Divide? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator BinaryExpression?(Divide? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Divide?(BinaryExpression? expr) => expr == null ? null : new Divide(expr);

			public void Deconstruct(out Type type, out Expr left, out Expr right)
			{
				type  = Expr.Type;
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}

			public void Deconstruct(out Expr left, out Expr right)
			{
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}
		}

		#endregion

		#region Equal

		public class Equal : Expr
		{
			public BinaryExpression Expr { get; }

			public Equal(BinaryExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?      (Equal? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator BinaryExpression?(Equal? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Equal?(BinaryExpression? expr) => expr == null ? null : new Equal(expr);

			public void Deconstruct(out Type type, out Expr left, out Expr right)
			{
				type  = Expr.Type;
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}

			public void Deconstruct(out Expr left, out Expr right)
			{
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}
		}

		#endregion

		#region ExclusiveOr

		public class ExclusiveOr : Expr
		{
			public BinaryExpression Expr { get; }

			public ExclusiveOr(BinaryExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?      (ExclusiveOr? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator BinaryExpression?(ExclusiveOr? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator ExclusiveOr?(BinaryExpression? expr) => expr == null ? null : new ExclusiveOr(expr);

			public void Deconstruct(out Type type, out Expr left, out Expr right)
			{
				type  = Expr.Type;
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}

			public void Deconstruct(out Expr left, out Expr right)
			{
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}
		}

		#endregion

		#region GreaterThan

		public class GreaterThan : Expr
		{
			public BinaryExpression Expr { get; }

			public GreaterThan(BinaryExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?      (GreaterThan? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator BinaryExpression?(GreaterThan? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator GreaterThan?(BinaryExpression? expr) => expr == null ? null : new GreaterThan(expr);

			public void Deconstruct(out Type type, out Expr left, out Expr right)
			{
				type  = Expr.Type;
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}

			public void Deconstruct(out Expr left, out Expr right)
			{
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}
		}

		#endregion

		#region GreaterThanOrEqual

		public class GreaterThanOrEqual : Expr
		{
			public BinaryExpression Expr { get; }

			public GreaterThanOrEqual(BinaryExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?      (GreaterThanOrEqual? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator BinaryExpression?(GreaterThanOrEqual? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator GreaterThanOrEqual?(BinaryExpression? expr) => expr == null ? null : new GreaterThanOrEqual(expr);

			public void Deconstruct(out Type type, out Expr left, out Expr right)
			{
				type  = Expr.Type;
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}

			public void Deconstruct(out Expr left, out Expr right)
			{
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}
		}

		#endregion

		#region LeftShift

		public class LeftShift : Expr
		{
			public BinaryExpression Expr { get; }

			public LeftShift(BinaryExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?      (LeftShift? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator BinaryExpression?(LeftShift? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator LeftShift?(BinaryExpression? expr) => expr == null ? null : new LeftShift(expr);

			public void Deconstruct(out Type type, out Expr left, out Expr right)
			{
				type  = Expr.Type;
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}

			public void Deconstruct(out Expr left, out Expr right)
			{
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}
		}

		#endregion

		#region LessThan

		public class LessThan : Expr
		{
			public BinaryExpression Expr { get; }

			public LessThan(BinaryExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?      (LessThan? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator BinaryExpression?(LessThan? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator LessThan?(BinaryExpression? expr) => expr == null ? null : new LessThan(expr);

			public void Deconstruct(out Type type, out Expr left, out Expr right)
			{
				type  = Expr.Type;
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}

			public void Deconstruct(out Expr left, out Expr right)
			{
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}
		}

		#endregion

		#region LessThanOrEqual

		public class LessThanOrEqual : Expr
		{
			public BinaryExpression Expr { get; }

			public LessThanOrEqual(BinaryExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?      (LessThanOrEqual? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator BinaryExpression?(LessThanOrEqual? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator LessThanOrEqual?(BinaryExpression? expr) => expr == null ? null : new LessThanOrEqual(expr);

			public void Deconstruct(out Type type, out Expr left, out Expr right)
			{
				type  = Expr.Type;
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}

			public void Deconstruct(out Expr left, out Expr right)
			{
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}
		}

		#endregion

		#region Modulo

		public class Modulo : Expr
		{
			public BinaryExpression Expr { get; }

			public Modulo(BinaryExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?      (Modulo? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator BinaryExpression?(Modulo? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Modulo?(BinaryExpression? expr) => expr == null ? null : new Modulo(expr);

			public void Deconstruct(out Type type, out Expr left, out Expr right)
			{
				type  = Expr.Type;
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}

			public void Deconstruct(out Expr left, out Expr right)
			{
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}
		}

		#endregion

		#region Multiply

		public class Multiply : Expr
		{
			public BinaryExpression Expr { get; }

			public Multiply(BinaryExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?      (Multiply? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator BinaryExpression?(Multiply? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Multiply?(BinaryExpression? expr) => expr == null ? null : new Multiply(expr);

			public void Deconstruct(out Type type, out Expr left, out Expr right)
			{
				type  = Expr.Type;
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}

			public void Deconstruct(out Expr left, out Expr right)
			{
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}
		}

		#endregion

		#region MultiplyChecked

		public class MultiplyChecked : Expr
		{
			public BinaryExpression Expr { get; }

			public MultiplyChecked(BinaryExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?      (MultiplyChecked? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator BinaryExpression?(MultiplyChecked? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator MultiplyChecked?(BinaryExpression? expr) => expr == null ? null : new MultiplyChecked(expr);

			public void Deconstruct(out Type type, out Expr left, out Expr right)
			{
				type  = Expr.Type;
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}

			public void Deconstruct(out Expr left, out Expr right)
			{
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}
		}

		#endregion

		#region NotEqual

		public class NotEqual : Expr
		{
			public BinaryExpression Expr { get; }

			public NotEqual(BinaryExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?      (NotEqual? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator BinaryExpression?(NotEqual? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator NotEqual?(BinaryExpression? expr) => expr == null ? null : new NotEqual(expr);

			public void Deconstruct(out Type type, out Expr left, out Expr right)
			{
				type  = Expr.Type;
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}

			public void Deconstruct(out Expr left, out Expr right)
			{
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}
		}

		#endregion

		#region Or

		public class Or : Expr
		{
			public BinaryExpression Expr { get; }

			public Or(BinaryExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?      (Or? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator BinaryExpression?(Or? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Or?(BinaryExpression? expr) => expr == null ? null : new Or(expr);

			public void Deconstruct(out Type type, out Expr left, out Expr right)
			{
				type  = Expr.Type;
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}

			public void Deconstruct(out Expr left, out Expr right)
			{
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}
		}

		#endregion

		#region OrElse

		public class OrElse : Expr
		{
			public BinaryExpression Expr { get; }

			public OrElse(BinaryExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?      (OrElse? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator BinaryExpression?(OrElse? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator OrElse?(BinaryExpression? expr) => expr == null ? null : new OrElse(expr);

			public void Deconstruct(out Type type, out Expr left, out Expr right)
			{
				type  = Expr.Type;
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}

			public void Deconstruct(out Expr left, out Expr right)
			{
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}
		}

		#endregion

		#region Power

		public class Power : Expr
		{
			public BinaryExpression Expr { get; }

			public Power(BinaryExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?      (Power? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator BinaryExpression?(Power? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Power?(BinaryExpression? expr) => expr == null ? null : new Power(expr);

			public void Deconstruct(out Type type, out Expr left, out Expr right)
			{
				type  = Expr.Type;
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}

			public void Deconstruct(out Expr left, out Expr right)
			{
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}
		}

		#endregion

		#region RightShift

		public class RightShift : Expr
		{
			public BinaryExpression Expr { get; }

			public RightShift(BinaryExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?      (RightShift? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator BinaryExpression?(RightShift? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator RightShift?(BinaryExpression? expr) => expr == null ? null : new RightShift(expr);

			public void Deconstruct(out Type type, out Expr left, out Expr right)
			{
				type  = Expr.Type;
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}

			public void Deconstruct(out Expr left, out Expr right)
			{
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}
		}

		#endregion

		#region Subtract

		public class Subtract : Expr
		{
			public BinaryExpression Expr { get; }

			public Subtract(BinaryExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?      (Subtract? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator BinaryExpression?(Subtract? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Subtract?(BinaryExpression? expr) => expr == null ? null : new Subtract(expr);

			public void Deconstruct(out Type type, out Expr left, out Expr right)
			{
				type  = Expr.Type;
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}

			public void Deconstruct(out Expr left, out Expr right)
			{
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}
		}

		#endregion

		#region SubtractChecked

		public class SubtractChecked : Expr
		{
			public BinaryExpression Expr { get; }

			public SubtractChecked(BinaryExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?      (SubtractChecked? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator BinaryExpression?(SubtractChecked? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator SubtractChecked?(BinaryExpression? expr) => expr == null ? null : new SubtractChecked(expr);

			public void Deconstruct(out Type type, out Expr left, out Expr right)
			{
				type  = Expr.Type;
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}

			public void Deconstruct(out Expr left, out Expr right)
			{
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}
		}

		#endregion

		#region AddAssign

		public class AddAssign : Expr
		{
			public BinaryExpression Expr { get; }

			public AddAssign(BinaryExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?      (AddAssign? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator BinaryExpression?(AddAssign? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator AddAssign?(BinaryExpression? expr) => expr == null ? null : new AddAssign(expr);

			public void Deconstruct(out Type type, out Expr left, out Expr right)
			{
				type  = Expr.Type;
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}

			public void Deconstruct(out Expr left, out Expr right)
			{
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}
		}

		#endregion

		#region AndAssign

		public class AndAssign : Expr
		{
			public BinaryExpression Expr { get; }

			public AndAssign(BinaryExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?      (AndAssign? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator BinaryExpression?(AndAssign? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator AndAssign?(BinaryExpression? expr) => expr == null ? null : new AndAssign(expr);

			public void Deconstruct(out Type type, out Expr left, out Expr right)
			{
				type  = Expr.Type;
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}

			public void Deconstruct(out Expr left, out Expr right)
			{
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}
		}

		#endregion

		#region DivideAssign

		public class DivideAssign : Expr
		{
			public BinaryExpression Expr { get; }

			public DivideAssign(BinaryExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?      (DivideAssign? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator BinaryExpression?(DivideAssign? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator DivideAssign?(BinaryExpression? expr) => expr == null ? null : new DivideAssign(expr);

			public void Deconstruct(out Type type, out Expr left, out Expr right)
			{
				type  = Expr.Type;
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}

			public void Deconstruct(out Expr left, out Expr right)
			{
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}
		}

		#endregion

		#region ExclusiveOrAssign

		public class ExclusiveOrAssign : Expr
		{
			public BinaryExpression Expr { get; }

			public ExclusiveOrAssign(BinaryExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?      (ExclusiveOrAssign? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator BinaryExpression?(ExclusiveOrAssign? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator ExclusiveOrAssign?(BinaryExpression? expr) => expr == null ? null : new ExclusiveOrAssign(expr);

			public void Deconstruct(out Type type, out Expr left, out Expr right)
			{
				type  = Expr.Type;
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}

			public void Deconstruct(out Expr left, out Expr right)
			{
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}
		}

		#endregion

		#region LeftShiftAssign

		public class LeftShiftAssign : Expr
		{
			public BinaryExpression Expr { get; }

			public LeftShiftAssign(BinaryExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?      (LeftShiftAssign? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator BinaryExpression?(LeftShiftAssign? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator LeftShiftAssign?(BinaryExpression? expr) => expr == null ? null : new LeftShiftAssign(expr);

			public void Deconstruct(out Type type, out Expr left, out Expr right)
			{
				type  = Expr.Type;
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}

			public void Deconstruct(out Expr left, out Expr right)
			{
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}
		}

		#endregion

		#region ModuloAssign

		public class ModuloAssign : Expr
		{
			public BinaryExpression Expr { get; }

			public ModuloAssign(BinaryExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?      (ModuloAssign? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator BinaryExpression?(ModuloAssign? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator ModuloAssign?(BinaryExpression? expr) => expr == null ? null : new ModuloAssign(expr);

			public void Deconstruct(out Type type, out Expr left, out Expr right)
			{
				type  = Expr.Type;
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}

			public void Deconstruct(out Expr left, out Expr right)
			{
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}
		}

		#endregion

		#region MultiplyAssign

		public class MultiplyAssign : Expr
		{
			public BinaryExpression Expr { get; }

			public MultiplyAssign(BinaryExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?      (MultiplyAssign? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator BinaryExpression?(MultiplyAssign? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator MultiplyAssign?(BinaryExpression? expr) => expr == null ? null : new MultiplyAssign(expr);

			public void Deconstruct(out Type type, out Expr left, out Expr right)
			{
				type  = Expr.Type;
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}

			public void Deconstruct(out Expr left, out Expr right)
			{
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}
		}

		#endregion

		#region OrAssign

		public class OrAssign : Expr
		{
			public BinaryExpression Expr { get; }

			public OrAssign(BinaryExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?      (OrAssign? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator BinaryExpression?(OrAssign? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator OrAssign?(BinaryExpression? expr) => expr == null ? null : new OrAssign(expr);

			public void Deconstruct(out Type type, out Expr left, out Expr right)
			{
				type  = Expr.Type;
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}

			public void Deconstruct(out Expr left, out Expr right)
			{
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}
		}

		#endregion

		#region PowerAssign

		public class PowerAssign : Expr
		{
			public BinaryExpression Expr { get; }

			public PowerAssign(BinaryExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?      (PowerAssign? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator BinaryExpression?(PowerAssign? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator PowerAssign?(BinaryExpression? expr) => expr == null ? null : new PowerAssign(expr);

			public void Deconstruct(out Type type, out Expr left, out Expr right)
			{
				type  = Expr.Type;
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}

			public void Deconstruct(out Expr left, out Expr right)
			{
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}
		}

		#endregion

		#region RightShiftAssign

		public class RightShiftAssign : Expr
		{
			public BinaryExpression Expr { get; }

			public RightShiftAssign(BinaryExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?      (RightShiftAssign? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator BinaryExpression?(RightShiftAssign? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator RightShiftAssign?(BinaryExpression? expr) => expr == null ? null : new RightShiftAssign(expr);

			public void Deconstruct(out Type type, out Expr left, out Expr right)
			{
				type  = Expr.Type;
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}

			public void Deconstruct(out Expr left, out Expr right)
			{
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}
		}

		#endregion

		#region SubtractAssign

		public class SubtractAssign : Expr
		{
			public BinaryExpression Expr { get; }

			public SubtractAssign(BinaryExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?      (SubtractAssign? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator BinaryExpression?(SubtractAssign? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator SubtractAssign?(BinaryExpression? expr) => expr == null ? null : new SubtractAssign(expr);

			public void Deconstruct(out Type type, out Expr left, out Expr right)
			{
				type  = Expr.Type;
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}

			public void Deconstruct(out Expr left, out Expr right)
			{
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}
		}

		#endregion

		#region AddAssignChecked

		public class AddAssignChecked : Expr
		{
			public BinaryExpression Expr { get; }

			public AddAssignChecked(BinaryExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?      (AddAssignChecked? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator BinaryExpression?(AddAssignChecked? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator AddAssignChecked?(BinaryExpression? expr) => expr == null ? null : new AddAssignChecked(expr);

			public void Deconstruct(out Type type, out Expr left, out Expr right)
			{
				type  = Expr.Type;
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}

			public void Deconstruct(out Expr left, out Expr right)
			{
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}
		}

		#endregion

		#region MultiplyAssignChecked

		public class MultiplyAssignChecked : Expr
		{
			public BinaryExpression Expr { get; }

			public MultiplyAssignChecked(BinaryExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?      (MultiplyAssignChecked? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator BinaryExpression?(MultiplyAssignChecked? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator MultiplyAssignChecked?(BinaryExpression? expr) => expr == null ? null : new MultiplyAssignChecked(expr);

			public void Deconstruct(out Type type, out Expr left, out Expr right)
			{
				type  = Expr.Type;
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}

			public void Deconstruct(out Expr left, out Expr right)
			{
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}
		}

		#endregion

		#region SubtractAssignChecked

		public class SubtractAssignChecked : Expr
		{
			public BinaryExpression Expr { get; }

			public SubtractAssignChecked(BinaryExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?      (SubtractAssignChecked? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator BinaryExpression?(SubtractAssignChecked? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator SubtractAssignChecked?(BinaryExpression? expr) => expr == null ? null : new SubtractAssignChecked(expr);

			public void Deconstruct(out Type type, out Expr left, out Expr right)
			{
				type  = Expr.Type;
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}

			public void Deconstruct(out Expr left, out Expr right)
			{
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}
		}

		#endregion

		#region ArrayLength

		public class ArrayLength : Expr
		{
			public UnaryExpression Expr { get; }

			public ArrayLength(UnaryExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?     (ArrayLength? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator UnaryExpression?(ArrayLength? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator ArrayLength?(UnaryExpression? expr) => expr == null ? null : new ArrayLength(expr);

			public void Deconstruct(out Type type, out Expr? operand)
			{
				type    = Expr.Type;
				operand = Expr.Operand.ToExpr();
			}

			public void Deconstruct(out Expr? operand)
			{
				operand = Expr.Operand.ToExpr();
			}
		}

		#endregion

		#region Convert

		public class Convert : Expr
		{
			public UnaryExpression Expr { get; }

			public Convert(UnaryExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?     (Convert? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator UnaryExpression?(Convert? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Convert?(UnaryExpression? expr) => expr == null ? null : new Convert(expr);

			public void Deconstruct(out Type type, out Expr? operand)
			{
				type    = Expr.Type;
				operand = Expr.Operand.ToExpr();
			}

			public void Deconstruct(out Expr? operand)
			{
				operand = Expr.Operand.ToExpr();
			}
		}

		#endregion

		#region ConvertChecked

		public class ConvertChecked : Expr
		{
			public UnaryExpression Expr { get; }

			public ConvertChecked(UnaryExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?     (ConvertChecked? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator UnaryExpression?(ConvertChecked? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator ConvertChecked?(UnaryExpression? expr) => expr == null ? null : new ConvertChecked(expr);

			public void Deconstruct(out Type type, out Expr? operand)
			{
				type    = Expr.Type;
				operand = Expr.Operand.ToExpr();
			}

			public void Deconstruct(out Expr? operand)
			{
				operand = Expr.Operand.ToExpr();
			}
		}

		#endregion

		#region Negate

		public class Negate : Expr
		{
			public UnaryExpression Expr { get; }

			public Negate(UnaryExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?     (Negate? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator UnaryExpression?(Negate? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Negate?(UnaryExpression? expr) => expr == null ? null : new Negate(expr);

			public void Deconstruct(out Type type, out Expr? operand)
			{
				type    = Expr.Type;
				operand = Expr.Operand.ToExpr();
			}

			public void Deconstruct(out Expr? operand)
			{
				operand = Expr.Operand.ToExpr();
			}
		}

		#endregion

		#region NegateChecked

		public class NegateChecked : Expr
		{
			public UnaryExpression Expr { get; }

			public NegateChecked(UnaryExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?     (NegateChecked? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator UnaryExpression?(NegateChecked? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator NegateChecked?(UnaryExpression? expr) => expr == null ? null : new NegateChecked(expr);

			public void Deconstruct(out Type type, out Expr? operand)
			{
				type    = Expr.Type;
				operand = Expr.Operand.ToExpr();
			}

			public void Deconstruct(out Expr? operand)
			{
				operand = Expr.Operand.ToExpr();
			}
		}

		#endregion

		#region Not

		public class Not : Expr
		{
			public UnaryExpression Expr { get; }

			public Not(UnaryExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?     (Not? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator UnaryExpression?(Not? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Not?(UnaryExpression? expr) => expr == null ? null : new Not(expr);

			public void Deconstruct(out Type type, out Expr? operand)
			{
				type    = Expr.Type;
				operand = Expr.Operand.ToExpr();
			}

			public void Deconstruct(out Expr? operand)
			{
				operand = Expr.Operand.ToExpr();
			}
		}

		#endregion

		#region Quote

		public class Quote : Expr
		{
			public UnaryExpression Expr { get; }

			public Quote(UnaryExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?     (Quote? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator UnaryExpression?(Quote? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Quote?(UnaryExpression? expr) => expr == null ? null : new Quote(expr);

			public void Deconstruct(out Type type, out Expr? operand)
			{
				type    = Expr.Type;
				operand = Expr.Operand.ToExpr();
			}

			public void Deconstruct(out Expr? operand)
			{
				operand = Expr.Operand.ToExpr();
			}
		}

		#endregion

		#region TypeAs

		public class TypeAs : Expr
		{
			public UnaryExpression Expr { get; }

			public TypeAs(UnaryExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?     (TypeAs? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator UnaryExpression?(TypeAs? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator TypeAs?(UnaryExpression? expr) => expr == null ? null : new TypeAs(expr);

			public void Deconstruct(out Type type, out Expr? operand)
			{
				type    = Expr.Type;
				operand = Expr.Operand.ToExpr();
			}

			public void Deconstruct(out Expr? operand)
			{
				operand = Expr.Operand.ToExpr();
			}
		}

		#endregion

		#region UnaryPlus

		public class UnaryPlus : Expr
		{
			public UnaryExpression Expr { get; }

			public UnaryPlus(UnaryExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?     (UnaryPlus? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator UnaryExpression?(UnaryPlus? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator UnaryPlus?(UnaryExpression? expr) => expr == null ? null : new UnaryPlus(expr);

			public void Deconstruct(out Type type, out Expr? operand)
			{
				type    = Expr.Type;
				operand = Expr.Operand.ToExpr();
			}

			public void Deconstruct(out Expr? operand)
			{
				operand = Expr.Operand.ToExpr();
			}
		}

		#endregion

		#region Decrement

		public class Decrement : Expr
		{
			public UnaryExpression Expr { get; }

			public Decrement(UnaryExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?     (Decrement? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator UnaryExpression?(Decrement? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Decrement?(UnaryExpression? expr) => expr == null ? null : new Decrement(expr);

			public void Deconstruct(out Type type, out Expr? operand)
			{
				type    = Expr.Type;
				operand = Expr.Operand.ToExpr();
			}

			public void Deconstruct(out Expr? operand)
			{
				operand = Expr.Operand.ToExpr();
			}
		}

		#endregion

		#region Increment

		public class Increment : Expr
		{
			public UnaryExpression Expr { get; }

			public Increment(UnaryExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?     (Increment? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator UnaryExpression?(Increment? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Increment?(UnaryExpression? expr) => expr == null ? null : new Increment(expr);

			public void Deconstruct(out Type type, out Expr? operand)
			{
				type    = Expr.Type;
				operand = Expr.Operand.ToExpr();
			}

			public void Deconstruct(out Expr? operand)
			{
				operand = Expr.Operand.ToExpr();
			}
		}

		#endregion

		#region IsFalse

		public class IsFalse : Expr
		{
			public UnaryExpression Expr { get; }

			public IsFalse(UnaryExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?     (IsFalse? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator UnaryExpression?(IsFalse? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator IsFalse?(UnaryExpression? expr) => expr == null ? null : new IsFalse(expr);

			public void Deconstruct(out Type type, out Expr? operand)
			{
				type    = Expr.Type;
				operand = Expr.Operand.ToExpr();
			}

			public void Deconstruct(out Expr? operand)
			{
				operand = Expr.Operand.ToExpr();
			}
		}

		#endregion

		#region IsTrue

		public class IsTrue : Expr
		{
			public UnaryExpression Expr { get; }

			public IsTrue(UnaryExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?     (IsTrue? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator UnaryExpression?(IsTrue? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator IsTrue?(UnaryExpression? expr) => expr == null ? null : new IsTrue(expr);

			public void Deconstruct(out Type type, out Expr? operand)
			{
				type    = Expr.Type;
				operand = Expr.Operand.ToExpr();
			}

			public void Deconstruct(out Expr? operand)
			{
				operand = Expr.Operand.ToExpr();
			}
		}

		#endregion

		#region Throw

		public class Throw : Expr
		{
			public UnaryExpression Expr { get; }

			public Throw(UnaryExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?     (Throw? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator UnaryExpression?(Throw? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Throw?(UnaryExpression? expr) => expr == null ? null : new Throw(expr);

			public void Deconstruct(out Type type, out Expr? operand)
			{
				type    = Expr.Type;
				operand = Expr.Operand.ToExpr();
			}

			public void Deconstruct(out Expr? operand)
			{
				operand = Expr.Operand.ToExpr();
			}
		}

		#endregion

		#region Unbox

		public class Unbox : Expr
		{
			public UnaryExpression Expr { get; }

			public Unbox(UnaryExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?     (Unbox? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator UnaryExpression?(Unbox? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Unbox?(UnaryExpression? expr) => expr == null ? null : new Unbox(expr);

			public void Deconstruct(out Type type, out Expr? operand)
			{
				type    = Expr.Type;
				operand = Expr.Operand.ToExpr();
			}

			public void Deconstruct(out Expr? operand)
			{
				operand = Expr.Operand.ToExpr();
			}
		}

		#endregion

		#region PreIncrementAssign

		public class PreIncrementAssign : Expr
		{
			public UnaryExpression Expr { get; }

			public PreIncrementAssign(UnaryExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?     (PreIncrementAssign? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator UnaryExpression?(PreIncrementAssign? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator PreIncrementAssign?(UnaryExpression? expr) => expr == null ? null : new PreIncrementAssign(expr);

			public void Deconstruct(out Type type, out Expr? operand)
			{
				type    = Expr.Type;
				operand = Expr.Operand.ToExpr();
			}

			public void Deconstruct(out Expr? operand)
			{
				operand = Expr.Operand.ToExpr();
			}
		}

		#endregion

		#region PreDecrementAssign

		public class PreDecrementAssign : Expr
		{
			public UnaryExpression Expr { get; }

			public PreDecrementAssign(UnaryExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?     (PreDecrementAssign? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator UnaryExpression?(PreDecrementAssign? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator PreDecrementAssign?(UnaryExpression? expr) => expr == null ? null : new PreDecrementAssign(expr);

			public void Deconstruct(out Type type, out Expr? operand)
			{
				type    = Expr.Type;
				operand = Expr.Operand.ToExpr();
			}

			public void Deconstruct(out Expr? operand)
			{
				operand = Expr.Operand.ToExpr();
			}
		}

		#endregion

		#region PostIncrementAssign

		public class PostIncrementAssign : Expr
		{
			public UnaryExpression Expr { get; }

			public PostIncrementAssign(UnaryExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?     (PostIncrementAssign? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator UnaryExpression?(PostIncrementAssign? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator PostIncrementAssign?(UnaryExpression? expr) => expr == null ? null : new PostIncrementAssign(expr);

			public void Deconstruct(out Type type, out Expr? operand)
			{
				type    = Expr.Type;
				operand = Expr.Operand.ToExpr();
			}

			public void Deconstruct(out Expr? operand)
			{
				operand = Expr.Operand.ToExpr();
			}
		}

		#endregion

		#region PostDecrementAssign

		public class PostDecrementAssign : Expr
		{
			public UnaryExpression Expr { get; }

			public PostDecrementAssign(UnaryExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?     (PostDecrementAssign? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator UnaryExpression?(PostDecrementAssign? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator PostDecrementAssign?(UnaryExpression? expr) => expr == null ? null : new PostDecrementAssign(expr);

			public void Deconstruct(out Type type, out Expr? operand)
			{
				type    = Expr.Type;
				operand = Expr.Operand.ToExpr();
			}

			public void Deconstruct(out Expr? operand)
			{
				operand = Expr.Operand.ToExpr();
			}
		}

		#endregion

		#region OnesComplement

		public class OnesComplement : Expr
		{
			public UnaryExpression Expr { get; }

			public OnesComplement(UnaryExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?     (OnesComplement? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator UnaryExpression?(OnesComplement? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator OnesComplement?(UnaryExpression? expr) => expr == null ? null : new OnesComplement(expr);

			public void Deconstruct(out Type type, out Expr? operand)
			{
				type    = Expr.Type;
				operand = Expr.Operand.ToExpr();
			}

			public void Deconstruct(out Expr? operand)
			{
				operand = Expr.Operand.ToExpr();
			}
		}

		#endregion

	}

	public static partial class Extensions
	{
		#region IEnumerable<ElementInit>

		public static void Deconstruct(this IEnumerable<ElementInit> list, out int count)
		{
			switch (list)
			{
				case ElementInit[]            arr : count = arr.Length; break;
				case ICollection<ElementInit> col : count = col.Count;  break;
				case null : count = -1; break;
				default   :
					using (var enumerator = list.GetEnumerator())
						count = enumerator.MoveNext() ? 1 : 0;
					break;
			}
		}

		public static void Deconstruct(this IEnumerable<ElementInit> list,
			out int count, out ElementInit? item0)
		{
			if (list == null) { count = -1; item0 = default; return; }

			count = 0;

			using var enumerator = list.GetEnumerator();

			if (enumerator.MoveNext())
			{
				count++;
				item0 = enumerator.Current;
	
				switch (list)
				{
					case ElementInit[]            arr : count = arr.Length; break;
					case ICollection<ElementInit> col : count = col.Count;  break;
					default : if (enumerator.MoveNext()) count++; break;
				}
			}
			else
			{
				item0 = default;
			}
		}

		public static void Deconstruct(this IEnumerable<ElementInit> list,
			out int count, out ElementInit? item0, out ElementInit? item1)
		{
			if (list == null) { count = -1; item0 = item1 = default; return; }

			count = 0;

			using var enumerator = list.GetEnumerator();

			if (enumerator.MoveNext())
			{
				count++;
				item0 = enumerator.Current;
	
				if (enumerator.MoveNext())
				{
					count++;
					item1 = enumerator.Current;
		
					switch (list)
					{
						case ElementInit[]            arr : count = arr.Length; break;
						case ICollection<ElementInit> col : count = col.Count;  break;
						default : if (enumerator.MoveNext()) count++; break;
					}
				}
				else
				{
					item1 = default;
				}
			}
			else
			{
				item1 = item0 = default;
			}
		}

		public static void Deconstruct(this IEnumerable<ElementInit> list,
			out int count, out ElementInit? item0, out ElementInit? item1, out ElementInit? item2)
		{
			if (list == null) { count = -1; item0 = item1 = item2 = default; return; }

			count = 0;

			using var enumerator = list.GetEnumerator();

			if (enumerator.MoveNext())
			{
				count++;
				item0 = enumerator.Current;
	
				if (enumerator.MoveNext())
				{
					count++;
					item1 = enumerator.Current;
		
					if (enumerator.MoveNext())
					{
						count++;
						item2 = enumerator.Current;
			
						switch (list)
						{
							case ElementInit[]            arr : count = arr.Length; break;
							case ICollection<ElementInit> col : count = col.Count;  break;
							default : if (enumerator.MoveNext()) count++; break;
						}
					}
					else
					{
						item2 = default;
					}
				}
				else
				{
					item2 = item1 = default;
				}
			}
			else
			{
				item2 = item1 = item0 = default;
			}
		}

		public static void Deconstruct(this IEnumerable<ElementInit> list,
			out int count, out ElementInit? item0, out ElementInit? item1, out ElementInit? item2, out ElementInit? item3)
		{
			if (list == null) { count = -1; item0 = item1 = item2 = item3 = default; return; }

			count = 0;

			using var enumerator = list.GetEnumerator();

			if (enumerator.MoveNext())
			{
				count++;
				item0 = enumerator.Current;
	
				if (enumerator.MoveNext())
				{
					count++;
					item1 = enumerator.Current;
		
					if (enumerator.MoveNext())
					{
						count++;
						item2 = enumerator.Current;
			
						if (enumerator.MoveNext())
						{
							count++;
							item3 = enumerator.Current;
				
							switch (list)
							{
								case ElementInit[]            arr : count = arr.Length; break;
								case ICollection<ElementInit> col : count = col.Count;  break;
								default : if (enumerator.MoveNext()) count++; break;
							}
						}
						else
						{
							item3 = default;
						}
					}
					else
					{
						item3 = item2 = default;
					}
				}
				else
				{
					item3 = item2 = item1 = default;
				}
			}
			else
			{
				item3 = item2 = item1 = item0 = default;
			}
		}

		public static void Deconstruct(this IEnumerable<ElementInit> list,
			out int count, out ElementInit? item0, out ElementInit? item1, out ElementInit? item2, out ElementInit? item3, out ElementInit? item4)
		{
			if (list == null) { count = -1; item0 = item1 = item2 = item3 = item4 = default; return; }

			count = 0;

			using var enumerator = list.GetEnumerator();

			if (enumerator.MoveNext())
			{
				count++;
				item0 = enumerator.Current;
	
				if (enumerator.MoveNext())
				{
					count++;
					item1 = enumerator.Current;
		
					if (enumerator.MoveNext())
					{
						count++;
						item2 = enumerator.Current;
			
						if (enumerator.MoveNext())
						{
							count++;
							item3 = enumerator.Current;
				
							if (enumerator.MoveNext())
							{
								count++;
								item4 = enumerator.Current;
					
								switch (list)
								{
									case ElementInit[]            arr : count = arr.Length; break;
									case ICollection<ElementInit> col : count = col.Count;  break;
									default : if (enumerator.MoveNext()) count++; break;
								}
							}
							else
							{
								item4 = default;
							}
						}
						else
						{
							item4 = item3 = default;
						}
					}
					else
					{
						item4 = item3 = item2 = default;
					}
				}
				else
				{
					item4 = item3 = item2 = item1 = default;
				}
			}
			else
			{
				item4 = item3 = item2 = item1 = item0 = default;
			}
		}

		public static void Deconstruct(this IEnumerable<ElementInit> list,
			out int count, out ElementInit? item0, out ElementInit? item1, out ElementInit? item2, out ElementInit? item3, out ElementInit? item4, out ElementInit? item5)
		{
			if (list == null) { count = -1; item0 = item1 = item2 = item3 = item4 = item5 = default; return; }

			count = 0;

			using var enumerator = list.GetEnumerator();

			if (enumerator.MoveNext())
			{
				count++;
				item0 = enumerator.Current;
	
				if (enumerator.MoveNext())
				{
					count++;
					item1 = enumerator.Current;
		
					if (enumerator.MoveNext())
					{
						count++;
						item2 = enumerator.Current;
			
						if (enumerator.MoveNext())
						{
							count++;
							item3 = enumerator.Current;
				
							if (enumerator.MoveNext())
							{
								count++;
								item4 = enumerator.Current;
					
								if (enumerator.MoveNext())
								{
									count++;
									item5 = enumerator.Current;
						
									switch (list)
									{
										case ElementInit[]            arr : count = arr.Length; break;
										case ICollection<ElementInit> col : count = col.Count;  break;
										default : if (enumerator.MoveNext()) count++; break;
									}
								}
								else
								{
									item5 = default;
								}
							}
							else
							{
								item5 = item4 = default;
							}
						}
						else
						{
							item5 = item4 = item3 = default;
						}
					}
					else
					{
						item5 = item4 = item3 = item2 = default;
					}
				}
				else
				{
					item5 = item4 = item3 = item2 = item1 = default;
				}
			}
			else
			{
				item5 = item4 = item3 = item2 = item1 = item0 = default;
			}
		}

		public static void Deconstruct(this IEnumerable<ElementInit> list,
			out int count, out ElementInit? item0, out ElementInit? item1, out ElementInit? item2, out ElementInit? item3, out ElementInit? item4, out ElementInit? item5, out ElementInit? item6)
		{
			if (list == null) { count = -1; item0 = item1 = item2 = item3 = item4 = item5 = item6 = default; return; }

			count = 0;

			using var enumerator = list.GetEnumerator();

			if (enumerator.MoveNext())
			{
				count++;
				item0 = enumerator.Current;
	
				if (enumerator.MoveNext())
				{
					count++;
					item1 = enumerator.Current;
		
					if (enumerator.MoveNext())
					{
						count++;
						item2 = enumerator.Current;
			
						if (enumerator.MoveNext())
						{
							count++;
							item3 = enumerator.Current;
				
							if (enumerator.MoveNext())
							{
								count++;
								item4 = enumerator.Current;
					
								if (enumerator.MoveNext())
								{
									count++;
									item5 = enumerator.Current;
						
									if (enumerator.MoveNext())
									{
										count++;
										item6 = enumerator.Current;
							
										switch (list)
										{
											case ElementInit[]            arr : count = arr.Length; break;
											case ICollection<ElementInit> col : count = col.Count;  break;
											default : if (enumerator.MoveNext()) count++; break;
										}
									}
									else
									{
										item6 = default;
									}
								}
								else
								{
									item6 = item5 = default;
								}
							}
							else
							{
								item6 = item5 = item4 = default;
							}
						}
						else
						{
							item6 = item5 = item4 = item3 = default;
						}
					}
					else
					{
						item6 = item5 = item4 = item3 = item2 = default;
					}
				}
				else
				{
					item6 = item5 = item4 = item3 = item2 = item1 = default;
				}
			}
			else
			{
				item6 = item5 = item4 = item3 = item2 = item1 = item0 = default;
			}
		}

		public static void Deconstruct(this IEnumerable<ElementInit> list,
			out int count, out ElementInit? item0, out ElementInit? item1, out ElementInit? item2, out ElementInit? item3, out ElementInit? item4, out ElementInit? item5, out ElementInit? item6, out ElementInit? item7)
		{
			if (list == null) { count = -1; item0 = item1 = item2 = item3 = item4 = item5 = item6 = item7 = default; return; }

			count = 0;

			using var enumerator = list.GetEnumerator();

			if (enumerator.MoveNext())
			{
				count++;
				item0 = enumerator.Current;
	
				if (enumerator.MoveNext())
				{
					count++;
					item1 = enumerator.Current;
		
					if (enumerator.MoveNext())
					{
						count++;
						item2 = enumerator.Current;
			
						if (enumerator.MoveNext())
						{
							count++;
							item3 = enumerator.Current;
				
							if (enumerator.MoveNext())
							{
								count++;
								item4 = enumerator.Current;
					
								if (enumerator.MoveNext())
								{
									count++;
									item5 = enumerator.Current;
						
									if (enumerator.MoveNext())
									{
										count++;
										item6 = enumerator.Current;
							
										if (enumerator.MoveNext())
										{
											count++;
											item7 = enumerator.Current;
								
											switch (list)
											{
												case ElementInit[]            arr : count = arr.Length; break;
												case ICollection<ElementInit> col : count = col.Count;  break;
												default : if (enumerator.MoveNext()) count++; break;
											}
										}
										else
										{
											item7 = default;
										}
									}
									else
									{
										item7 = item6 = default;
									}
								}
								else
								{
									item7 = item6 = item5 = default;
								}
							}
							else
							{
								item7 = item6 = item5 = item4 = default;
							}
						}
						else
						{
							item7 = item6 = item5 = item4 = item3 = default;
						}
					}
					else
					{
						item7 = item6 = item5 = item4 = item3 = item2 = default;
					}
				}
				else
				{
					item7 = item6 = item5 = item4 = item3 = item2 = item1 = default;
				}
			}
			else
			{
				item7 = item6 = item5 = item4 = item3 = item2 = item1 = item0 = default;
			}
		}

		public static void Deconstruct(this IEnumerable<ElementInit> list,
			out int count, out ElementInit? item0, out ElementInit? item1, out ElementInit? item2, out ElementInit? item3, out ElementInit? item4, out ElementInit? item5, out ElementInit? item6, out ElementInit? item7, out ElementInit? item8)
		{
			if (list == null) { count = -1; item0 = item1 = item2 = item3 = item4 = item5 = item6 = item7 = item8 = default; return; }

			count = 0;

			using var enumerator = list.GetEnumerator();

			if (enumerator.MoveNext())
			{
				count++;
				item0 = enumerator.Current;
	
				if (enumerator.MoveNext())
				{
					count++;
					item1 = enumerator.Current;
		
					if (enumerator.MoveNext())
					{
						count++;
						item2 = enumerator.Current;
			
						if (enumerator.MoveNext())
						{
							count++;
							item3 = enumerator.Current;
				
							if (enumerator.MoveNext())
							{
								count++;
								item4 = enumerator.Current;
					
								if (enumerator.MoveNext())
								{
									count++;
									item5 = enumerator.Current;
						
									if (enumerator.MoveNext())
									{
										count++;
										item6 = enumerator.Current;
							
										if (enumerator.MoveNext())
										{
											count++;
											item7 = enumerator.Current;
								
											if (enumerator.MoveNext())
											{
												count++;
												item8 = enumerator.Current;
									
												switch (list)
												{
													case ElementInit[]            arr : count = arr.Length; break;
													case ICollection<ElementInit> col : count = col.Count;  break;
													default : if (enumerator.MoveNext()) count++; break;
												}
											}
											else
											{
												item8 = default;
											}
										}
										else
										{
											item8 = item7 = default;
										}
									}
									else
									{
										item8 = item7 = item6 = default;
									}
								}
								else
								{
									item8 = item7 = item6 = item5 = default;
								}
							}
							else
							{
								item8 = item7 = item6 = item5 = item4 = default;
							}
						}
						else
						{
							item8 = item7 = item6 = item5 = item4 = item3 = default;
						}
					}
					else
					{
						item8 = item7 = item6 = item5 = item4 = item3 = item2 = default;
					}
				}
				else
				{
					item8 = item7 = item6 = item5 = item4 = item3 = item2 = item1 = default;
				}
			}
			else
			{
				item8 = item7 = item6 = item5 = item4 = item3 = item2 = item1 = item0 = default;
			}
		}

		public static void Deconstruct(this IEnumerable<ElementInit> list,
			out int count, out ElementInit? item0, out ElementInit? item1, out ElementInit? item2, out ElementInit? item3, out ElementInit? item4, out ElementInit? item5, out ElementInit? item6, out ElementInit? item7, out ElementInit? item8, out ElementInit? item9)
		{
			if (list == null) { count = -1; item0 = item1 = item2 = item3 = item4 = item5 = item6 = item7 = item8 = item9 = default; return; }

			count = 0;

			using var enumerator = list.GetEnumerator();

			if (enumerator.MoveNext())
			{
				count++;
				item0 = enumerator.Current;
	
				if (enumerator.MoveNext())
				{
					count++;
					item1 = enumerator.Current;
		
					if (enumerator.MoveNext())
					{
						count++;
						item2 = enumerator.Current;
			
						if (enumerator.MoveNext())
						{
							count++;
							item3 = enumerator.Current;
				
							if (enumerator.MoveNext())
							{
								count++;
								item4 = enumerator.Current;
					
								if (enumerator.MoveNext())
								{
									count++;
									item5 = enumerator.Current;
						
									if (enumerator.MoveNext())
									{
										count++;
										item6 = enumerator.Current;
							
										if (enumerator.MoveNext())
										{
											count++;
											item7 = enumerator.Current;
								
											if (enumerator.MoveNext())
											{
												count++;
												item8 = enumerator.Current;
									
												if (enumerator.MoveNext())
												{
													count++;
													item9 = enumerator.Current;
										
													switch (list)
													{
														case ElementInit[]            arr : count = arr.Length; break;
														case ICollection<ElementInit> col : count = col.Count;  break;
														default : if (enumerator.MoveNext()) count++; break;
													}
												}
												else
												{
													item9 = default;
												}
											}
											else
											{
												item9 = item8 = default;
											}
										}
										else
										{
											item9 = item8 = item7 = default;
										}
									}
									else
									{
										item9 = item8 = item7 = item6 = default;
									}
								}
								else
								{
									item9 = item8 = item7 = item6 = item5 = default;
								}
							}
							else
							{
								item9 = item8 = item7 = item6 = item5 = item4 = default;
							}
						}
						else
						{
							item9 = item8 = item7 = item6 = item5 = item4 = item3 = default;
						}
					}
					else
					{
						item9 = item8 = item7 = item6 = item5 = item4 = item3 = item2 = default;
					}
				}
				else
				{
					item9 = item8 = item7 = item6 = item5 = item4 = item3 = item2 = item1 = default;
				}
			}
			else
			{
				item9 = item8 = item7 = item6 = item5 = item4 = item3 = item2 = item1 = item0 = default;
			}
		}

		#endregion

		#region IEnumerable<CatchBlock>

		public static void Deconstruct(this IEnumerable<CatchBlock> list, out int count)
		{
			switch (list)
			{
				case CatchBlock[]            arr : count = arr.Length; break;
				case ICollection<CatchBlock> col : count = col.Count;  break;
				case null : count = -1; break;
				default   :
					using (var enumerator = list.GetEnumerator())
						count = enumerator.MoveNext() ? 1 : 0;
					break;
			}
		}

		public static void Deconstruct(this IEnumerable<CatchBlock> list,
			out int count, out CatchBlock? item0)
		{
			if (list == null) { count = -1; item0 = default; return; }

			count = 0;

			using var enumerator = list.GetEnumerator();

			if (enumerator.MoveNext())
			{
				count++;
				item0 = enumerator.Current;
	
				switch (list)
				{
					case CatchBlock[]            arr : count = arr.Length; break;
					case ICollection<CatchBlock> col : count = col.Count;  break;
					default : if (enumerator.MoveNext()) count++; break;
				}
			}
			else
			{
				item0 = default;
			}
		}

		public static void Deconstruct(this IEnumerable<CatchBlock> list,
			out int count, out CatchBlock? item0, out CatchBlock? item1)
		{
			if (list == null) { count = -1; item0 = item1 = default; return; }

			count = 0;

			using var enumerator = list.GetEnumerator();

			if (enumerator.MoveNext())
			{
				count++;
				item0 = enumerator.Current;
	
				if (enumerator.MoveNext())
				{
					count++;
					item1 = enumerator.Current;
		
					switch (list)
					{
						case CatchBlock[]            arr : count = arr.Length; break;
						case ICollection<CatchBlock> col : count = col.Count;  break;
						default : if (enumerator.MoveNext()) count++; break;
					}
				}
				else
				{
					item1 = default;
				}
			}
			else
			{
				item1 = item0 = default;
			}
		}

		public static void Deconstruct(this IEnumerable<CatchBlock> list,
			out int count, out CatchBlock? item0, out CatchBlock? item1, out CatchBlock? item2)
		{
			if (list == null) { count = -1; item0 = item1 = item2 = default; return; }

			count = 0;

			using var enumerator = list.GetEnumerator();

			if (enumerator.MoveNext())
			{
				count++;
				item0 = enumerator.Current;
	
				if (enumerator.MoveNext())
				{
					count++;
					item1 = enumerator.Current;
		
					if (enumerator.MoveNext())
					{
						count++;
						item2 = enumerator.Current;
			
						switch (list)
						{
							case CatchBlock[]            arr : count = arr.Length; break;
							case ICollection<CatchBlock> col : count = col.Count;  break;
							default : if (enumerator.MoveNext()) count++; break;
						}
					}
					else
					{
						item2 = default;
					}
				}
				else
				{
					item2 = item1 = default;
				}
			}
			else
			{
				item2 = item1 = item0 = default;
			}
		}

		public static void Deconstruct(this IEnumerable<CatchBlock> list,
			out int count, out CatchBlock? item0, out CatchBlock? item1, out CatchBlock? item2, out CatchBlock? item3)
		{
			if (list == null) { count = -1; item0 = item1 = item2 = item3 = default; return; }

			count = 0;

			using var enumerator = list.GetEnumerator();

			if (enumerator.MoveNext())
			{
				count++;
				item0 = enumerator.Current;
	
				if (enumerator.MoveNext())
				{
					count++;
					item1 = enumerator.Current;
		
					if (enumerator.MoveNext())
					{
						count++;
						item2 = enumerator.Current;
			
						if (enumerator.MoveNext())
						{
							count++;
							item3 = enumerator.Current;
				
							switch (list)
							{
								case CatchBlock[]            arr : count = arr.Length; break;
								case ICollection<CatchBlock> col : count = col.Count;  break;
								default : if (enumerator.MoveNext()) count++; break;
							}
						}
						else
						{
							item3 = default;
						}
					}
					else
					{
						item3 = item2 = default;
					}
				}
				else
				{
					item3 = item2 = item1 = default;
				}
			}
			else
			{
				item3 = item2 = item1 = item0 = default;
			}
		}

		public static void Deconstruct(this IEnumerable<CatchBlock> list,
			out int count, out CatchBlock? item0, out CatchBlock? item1, out CatchBlock? item2, out CatchBlock? item3, out CatchBlock? item4)
		{
			if (list == null) { count = -1; item0 = item1 = item2 = item3 = item4 = default; return; }

			count = 0;

			using var enumerator = list.GetEnumerator();

			if (enumerator.MoveNext())
			{
				count++;
				item0 = enumerator.Current;
	
				if (enumerator.MoveNext())
				{
					count++;
					item1 = enumerator.Current;
		
					if (enumerator.MoveNext())
					{
						count++;
						item2 = enumerator.Current;
			
						if (enumerator.MoveNext())
						{
							count++;
							item3 = enumerator.Current;
				
							if (enumerator.MoveNext())
							{
								count++;
								item4 = enumerator.Current;
					
								switch (list)
								{
									case CatchBlock[]            arr : count = arr.Length; break;
									case ICollection<CatchBlock> col : count = col.Count;  break;
									default : if (enumerator.MoveNext()) count++; break;
								}
							}
							else
							{
								item4 = default;
							}
						}
						else
						{
							item4 = item3 = default;
						}
					}
					else
					{
						item4 = item3 = item2 = default;
					}
				}
				else
				{
					item4 = item3 = item2 = item1 = default;
				}
			}
			else
			{
				item4 = item3 = item2 = item1 = item0 = default;
			}
		}

		public static void Deconstruct(this IEnumerable<CatchBlock> list,
			out int count, out CatchBlock? item0, out CatchBlock? item1, out CatchBlock? item2, out CatchBlock? item3, out CatchBlock? item4, out CatchBlock? item5)
		{
			if (list == null) { count = -1; item0 = item1 = item2 = item3 = item4 = item5 = default; return; }

			count = 0;

			using var enumerator = list.GetEnumerator();

			if (enumerator.MoveNext())
			{
				count++;
				item0 = enumerator.Current;
	
				if (enumerator.MoveNext())
				{
					count++;
					item1 = enumerator.Current;
		
					if (enumerator.MoveNext())
					{
						count++;
						item2 = enumerator.Current;
			
						if (enumerator.MoveNext())
						{
							count++;
							item3 = enumerator.Current;
				
							if (enumerator.MoveNext())
							{
								count++;
								item4 = enumerator.Current;
					
								if (enumerator.MoveNext())
								{
									count++;
									item5 = enumerator.Current;
						
									switch (list)
									{
										case CatchBlock[]            arr : count = arr.Length; break;
										case ICollection<CatchBlock> col : count = col.Count;  break;
										default : if (enumerator.MoveNext()) count++; break;
									}
								}
								else
								{
									item5 = default;
								}
							}
							else
							{
								item5 = item4 = default;
							}
						}
						else
						{
							item5 = item4 = item3 = default;
						}
					}
					else
					{
						item5 = item4 = item3 = item2 = default;
					}
				}
				else
				{
					item5 = item4 = item3 = item2 = item1 = default;
				}
			}
			else
			{
				item5 = item4 = item3 = item2 = item1 = item0 = default;
			}
		}

		public static void Deconstruct(this IEnumerable<CatchBlock> list,
			out int count, out CatchBlock? item0, out CatchBlock? item1, out CatchBlock? item2, out CatchBlock? item3, out CatchBlock? item4, out CatchBlock? item5, out CatchBlock? item6)
		{
			if (list == null) { count = -1; item0 = item1 = item2 = item3 = item4 = item5 = item6 = default; return; }

			count = 0;

			using var enumerator = list.GetEnumerator();

			if (enumerator.MoveNext())
			{
				count++;
				item0 = enumerator.Current;
	
				if (enumerator.MoveNext())
				{
					count++;
					item1 = enumerator.Current;
		
					if (enumerator.MoveNext())
					{
						count++;
						item2 = enumerator.Current;
			
						if (enumerator.MoveNext())
						{
							count++;
							item3 = enumerator.Current;
				
							if (enumerator.MoveNext())
							{
								count++;
								item4 = enumerator.Current;
					
								if (enumerator.MoveNext())
								{
									count++;
									item5 = enumerator.Current;
						
									if (enumerator.MoveNext())
									{
										count++;
										item6 = enumerator.Current;
							
										switch (list)
										{
											case CatchBlock[]            arr : count = arr.Length; break;
											case ICollection<CatchBlock> col : count = col.Count;  break;
											default : if (enumerator.MoveNext()) count++; break;
										}
									}
									else
									{
										item6 = default;
									}
								}
								else
								{
									item6 = item5 = default;
								}
							}
							else
							{
								item6 = item5 = item4 = default;
							}
						}
						else
						{
							item6 = item5 = item4 = item3 = default;
						}
					}
					else
					{
						item6 = item5 = item4 = item3 = item2 = default;
					}
				}
				else
				{
					item6 = item5 = item4 = item3 = item2 = item1 = default;
				}
			}
			else
			{
				item6 = item5 = item4 = item3 = item2 = item1 = item0 = default;
			}
		}

		public static void Deconstruct(this IEnumerable<CatchBlock> list,
			out int count, out CatchBlock? item0, out CatchBlock? item1, out CatchBlock? item2, out CatchBlock? item3, out CatchBlock? item4, out CatchBlock? item5, out CatchBlock? item6, out CatchBlock? item7)
		{
			if (list == null) { count = -1; item0 = item1 = item2 = item3 = item4 = item5 = item6 = item7 = default; return; }

			count = 0;

			using var enumerator = list.GetEnumerator();

			if (enumerator.MoveNext())
			{
				count++;
				item0 = enumerator.Current;
	
				if (enumerator.MoveNext())
				{
					count++;
					item1 = enumerator.Current;
		
					if (enumerator.MoveNext())
					{
						count++;
						item2 = enumerator.Current;
			
						if (enumerator.MoveNext())
						{
							count++;
							item3 = enumerator.Current;
				
							if (enumerator.MoveNext())
							{
								count++;
								item4 = enumerator.Current;
					
								if (enumerator.MoveNext())
								{
									count++;
									item5 = enumerator.Current;
						
									if (enumerator.MoveNext())
									{
										count++;
										item6 = enumerator.Current;
							
										if (enumerator.MoveNext())
										{
											count++;
											item7 = enumerator.Current;
								
											switch (list)
											{
												case CatchBlock[]            arr : count = arr.Length; break;
												case ICollection<CatchBlock> col : count = col.Count;  break;
												default : if (enumerator.MoveNext()) count++; break;
											}
										}
										else
										{
											item7 = default;
										}
									}
									else
									{
										item7 = item6 = default;
									}
								}
								else
								{
									item7 = item6 = item5 = default;
								}
							}
							else
							{
								item7 = item6 = item5 = item4 = default;
							}
						}
						else
						{
							item7 = item6 = item5 = item4 = item3 = default;
						}
					}
					else
					{
						item7 = item6 = item5 = item4 = item3 = item2 = default;
					}
				}
				else
				{
					item7 = item6 = item5 = item4 = item3 = item2 = item1 = default;
				}
			}
			else
			{
				item7 = item6 = item5 = item4 = item3 = item2 = item1 = item0 = default;
			}
		}

		public static void Deconstruct(this IEnumerable<CatchBlock> list,
			out int count, out CatchBlock? item0, out CatchBlock? item1, out CatchBlock? item2, out CatchBlock? item3, out CatchBlock? item4, out CatchBlock? item5, out CatchBlock? item6, out CatchBlock? item7, out CatchBlock? item8)
		{
			if (list == null) { count = -1; item0 = item1 = item2 = item3 = item4 = item5 = item6 = item7 = item8 = default; return; }

			count = 0;

			using var enumerator = list.GetEnumerator();

			if (enumerator.MoveNext())
			{
				count++;
				item0 = enumerator.Current;
	
				if (enumerator.MoveNext())
				{
					count++;
					item1 = enumerator.Current;
		
					if (enumerator.MoveNext())
					{
						count++;
						item2 = enumerator.Current;
			
						if (enumerator.MoveNext())
						{
							count++;
							item3 = enumerator.Current;
				
							if (enumerator.MoveNext())
							{
								count++;
								item4 = enumerator.Current;
					
								if (enumerator.MoveNext())
								{
									count++;
									item5 = enumerator.Current;
						
									if (enumerator.MoveNext())
									{
										count++;
										item6 = enumerator.Current;
							
										if (enumerator.MoveNext())
										{
											count++;
											item7 = enumerator.Current;
								
											if (enumerator.MoveNext())
											{
												count++;
												item8 = enumerator.Current;
									
												switch (list)
												{
													case CatchBlock[]            arr : count = arr.Length; break;
													case ICollection<CatchBlock> col : count = col.Count;  break;
													default : if (enumerator.MoveNext()) count++; break;
												}
											}
											else
											{
												item8 = default;
											}
										}
										else
										{
											item8 = item7 = default;
										}
									}
									else
									{
										item8 = item7 = item6 = default;
									}
								}
								else
								{
									item8 = item7 = item6 = item5 = default;
								}
							}
							else
							{
								item8 = item7 = item6 = item5 = item4 = default;
							}
						}
						else
						{
							item8 = item7 = item6 = item5 = item4 = item3 = default;
						}
					}
					else
					{
						item8 = item7 = item6 = item5 = item4 = item3 = item2 = default;
					}
				}
				else
				{
					item8 = item7 = item6 = item5 = item4 = item3 = item2 = item1 = default;
				}
			}
			else
			{
				item8 = item7 = item6 = item5 = item4 = item3 = item2 = item1 = item0 = default;
			}
		}

		public static void Deconstruct(this IEnumerable<CatchBlock> list,
			out int count, out CatchBlock? item0, out CatchBlock? item1, out CatchBlock? item2, out CatchBlock? item3, out CatchBlock? item4, out CatchBlock? item5, out CatchBlock? item6, out CatchBlock? item7, out CatchBlock? item8, out CatchBlock? item9)
		{
			if (list == null) { count = -1; item0 = item1 = item2 = item3 = item4 = item5 = item6 = item7 = item8 = item9 = default; return; }

			count = 0;

			using var enumerator = list.GetEnumerator();

			if (enumerator.MoveNext())
			{
				count++;
				item0 = enumerator.Current;
	
				if (enumerator.MoveNext())
				{
					count++;
					item1 = enumerator.Current;
		
					if (enumerator.MoveNext())
					{
						count++;
						item2 = enumerator.Current;
			
						if (enumerator.MoveNext())
						{
							count++;
							item3 = enumerator.Current;
				
							if (enumerator.MoveNext())
							{
								count++;
								item4 = enumerator.Current;
					
								if (enumerator.MoveNext())
								{
									count++;
									item5 = enumerator.Current;
						
									if (enumerator.MoveNext())
									{
										count++;
										item6 = enumerator.Current;
							
										if (enumerator.MoveNext())
										{
											count++;
											item7 = enumerator.Current;
								
											if (enumerator.MoveNext())
											{
												count++;
												item8 = enumerator.Current;
									
												if (enumerator.MoveNext())
												{
													count++;
													item9 = enumerator.Current;
										
													switch (list)
													{
														case CatchBlock[]            arr : count = arr.Length; break;
														case ICollection<CatchBlock> col : count = col.Count;  break;
														default : if (enumerator.MoveNext()) count++; break;
													}
												}
												else
												{
													item9 = default;
												}
											}
											else
											{
												item9 = item8 = default;
											}
										}
										else
										{
											item9 = item8 = item7 = default;
										}
									}
									else
									{
										item9 = item8 = item7 = item6 = default;
									}
								}
								else
								{
									item9 = item8 = item7 = item6 = item5 = default;
								}
							}
							else
							{
								item9 = item8 = item7 = item6 = item5 = item4 = default;
							}
						}
						else
						{
							item9 = item8 = item7 = item6 = item5 = item4 = item3 = default;
						}
					}
					else
					{
						item9 = item8 = item7 = item6 = item5 = item4 = item3 = item2 = default;
					}
				}
				else
				{
					item9 = item8 = item7 = item6 = item5 = item4 = item3 = item2 = item1 = default;
				}
			}
			else
			{
				item9 = item8 = item7 = item6 = item5 = item4 = item3 = item2 = item1 = item0 = default;
			}
		}

		#endregion

		#region IEnumerable<SwitchCase>

		public static void Deconstruct(this IEnumerable<SwitchCase> list, out int count)
		{
			switch (list)
			{
				case SwitchCase[]            arr : count = arr.Length; break;
				case ICollection<SwitchCase> col : count = col.Count;  break;
				case null : count = -1; break;
				default   :
					using (var enumerator = list.GetEnumerator())
						count = enumerator.MoveNext() ? 1 : 0;
					break;
			}
		}

		public static void Deconstruct(this IEnumerable<SwitchCase> list,
			out int count, out SwitchCase? item0)
		{
			if (list == null) { count = -1; item0 = default; return; }

			count = 0;

			using var enumerator = list.GetEnumerator();

			if (enumerator.MoveNext())
			{
				count++;
				item0 = enumerator.Current;
	
				switch (list)
				{
					case SwitchCase[]            arr : count = arr.Length; break;
					case ICollection<SwitchCase> col : count = col.Count;  break;
					default : if (enumerator.MoveNext()) count++; break;
				}
			}
			else
			{
				item0 = default;
			}
		}

		public static void Deconstruct(this IEnumerable<SwitchCase> list,
			out int count, out SwitchCase? item0, out SwitchCase? item1)
		{
			if (list == null) { count = -1; item0 = item1 = default; return; }

			count = 0;

			using var enumerator = list.GetEnumerator();

			if (enumerator.MoveNext())
			{
				count++;
				item0 = enumerator.Current;
	
				if (enumerator.MoveNext())
				{
					count++;
					item1 = enumerator.Current;
		
					switch (list)
					{
						case SwitchCase[]            arr : count = arr.Length; break;
						case ICollection<SwitchCase> col : count = col.Count;  break;
						default : if (enumerator.MoveNext()) count++; break;
					}
				}
				else
				{
					item1 = default;
				}
			}
			else
			{
				item1 = item0 = default;
			}
		}

		public static void Deconstruct(this IEnumerable<SwitchCase> list,
			out int count, out SwitchCase? item0, out SwitchCase? item1, out SwitchCase? item2)
		{
			if (list == null) { count = -1; item0 = item1 = item2 = default; return; }

			count = 0;

			using var enumerator = list.GetEnumerator();

			if (enumerator.MoveNext())
			{
				count++;
				item0 = enumerator.Current;
	
				if (enumerator.MoveNext())
				{
					count++;
					item1 = enumerator.Current;
		
					if (enumerator.MoveNext())
					{
						count++;
						item2 = enumerator.Current;
			
						switch (list)
						{
							case SwitchCase[]            arr : count = arr.Length; break;
							case ICollection<SwitchCase> col : count = col.Count;  break;
							default : if (enumerator.MoveNext()) count++; break;
						}
					}
					else
					{
						item2 = default;
					}
				}
				else
				{
					item2 = item1 = default;
				}
			}
			else
			{
				item2 = item1 = item0 = default;
			}
		}

		public static void Deconstruct(this IEnumerable<SwitchCase> list,
			out int count, out SwitchCase? item0, out SwitchCase? item1, out SwitchCase? item2, out SwitchCase? item3)
		{
			if (list == null) { count = -1; item0 = item1 = item2 = item3 = default; return; }

			count = 0;

			using var enumerator = list.GetEnumerator();

			if (enumerator.MoveNext())
			{
				count++;
				item0 = enumerator.Current;
	
				if (enumerator.MoveNext())
				{
					count++;
					item1 = enumerator.Current;
		
					if (enumerator.MoveNext())
					{
						count++;
						item2 = enumerator.Current;
			
						if (enumerator.MoveNext())
						{
							count++;
							item3 = enumerator.Current;
				
							switch (list)
							{
								case SwitchCase[]            arr : count = arr.Length; break;
								case ICollection<SwitchCase> col : count = col.Count;  break;
								default : if (enumerator.MoveNext()) count++; break;
							}
						}
						else
						{
							item3 = default;
						}
					}
					else
					{
						item3 = item2 = default;
					}
				}
				else
				{
					item3 = item2 = item1 = default;
				}
			}
			else
			{
				item3 = item2 = item1 = item0 = default;
			}
		}

		public static void Deconstruct(this IEnumerable<SwitchCase> list,
			out int count, out SwitchCase? item0, out SwitchCase? item1, out SwitchCase? item2, out SwitchCase? item3, out SwitchCase? item4)
		{
			if (list == null) { count = -1; item0 = item1 = item2 = item3 = item4 = default; return; }

			count = 0;

			using var enumerator = list.GetEnumerator();

			if (enumerator.MoveNext())
			{
				count++;
				item0 = enumerator.Current;
	
				if (enumerator.MoveNext())
				{
					count++;
					item1 = enumerator.Current;
		
					if (enumerator.MoveNext())
					{
						count++;
						item2 = enumerator.Current;
			
						if (enumerator.MoveNext())
						{
							count++;
							item3 = enumerator.Current;
				
							if (enumerator.MoveNext())
							{
								count++;
								item4 = enumerator.Current;
					
								switch (list)
								{
									case SwitchCase[]            arr : count = arr.Length; break;
									case ICollection<SwitchCase> col : count = col.Count;  break;
									default : if (enumerator.MoveNext()) count++; break;
								}
							}
							else
							{
								item4 = default;
							}
						}
						else
						{
							item4 = item3 = default;
						}
					}
					else
					{
						item4 = item3 = item2 = default;
					}
				}
				else
				{
					item4 = item3 = item2 = item1 = default;
				}
			}
			else
			{
				item4 = item3 = item2 = item1 = item0 = default;
			}
		}

		public static void Deconstruct(this IEnumerable<SwitchCase> list,
			out int count, out SwitchCase? item0, out SwitchCase? item1, out SwitchCase? item2, out SwitchCase? item3, out SwitchCase? item4, out SwitchCase? item5)
		{
			if (list == null) { count = -1; item0 = item1 = item2 = item3 = item4 = item5 = default; return; }

			count = 0;

			using var enumerator = list.GetEnumerator();

			if (enumerator.MoveNext())
			{
				count++;
				item0 = enumerator.Current;
	
				if (enumerator.MoveNext())
				{
					count++;
					item1 = enumerator.Current;
		
					if (enumerator.MoveNext())
					{
						count++;
						item2 = enumerator.Current;
			
						if (enumerator.MoveNext())
						{
							count++;
							item3 = enumerator.Current;
				
							if (enumerator.MoveNext())
							{
								count++;
								item4 = enumerator.Current;
					
								if (enumerator.MoveNext())
								{
									count++;
									item5 = enumerator.Current;
						
									switch (list)
									{
										case SwitchCase[]            arr : count = arr.Length; break;
										case ICollection<SwitchCase> col : count = col.Count;  break;
										default : if (enumerator.MoveNext()) count++; break;
									}
								}
								else
								{
									item5 = default;
								}
							}
							else
							{
								item5 = item4 = default;
							}
						}
						else
						{
							item5 = item4 = item3 = default;
						}
					}
					else
					{
						item5 = item4 = item3 = item2 = default;
					}
				}
				else
				{
					item5 = item4 = item3 = item2 = item1 = default;
				}
			}
			else
			{
				item5 = item4 = item3 = item2 = item1 = item0 = default;
			}
		}

		public static void Deconstruct(this IEnumerable<SwitchCase> list,
			out int count, out SwitchCase? item0, out SwitchCase? item1, out SwitchCase? item2, out SwitchCase? item3, out SwitchCase? item4, out SwitchCase? item5, out SwitchCase? item6)
		{
			if (list == null) { count = -1; item0 = item1 = item2 = item3 = item4 = item5 = item6 = default; return; }

			count = 0;

			using var enumerator = list.GetEnumerator();

			if (enumerator.MoveNext())
			{
				count++;
				item0 = enumerator.Current;
	
				if (enumerator.MoveNext())
				{
					count++;
					item1 = enumerator.Current;
		
					if (enumerator.MoveNext())
					{
						count++;
						item2 = enumerator.Current;
			
						if (enumerator.MoveNext())
						{
							count++;
							item3 = enumerator.Current;
				
							if (enumerator.MoveNext())
							{
								count++;
								item4 = enumerator.Current;
					
								if (enumerator.MoveNext())
								{
									count++;
									item5 = enumerator.Current;
						
									if (enumerator.MoveNext())
									{
										count++;
										item6 = enumerator.Current;
							
										switch (list)
										{
											case SwitchCase[]            arr : count = arr.Length; break;
											case ICollection<SwitchCase> col : count = col.Count;  break;
											default : if (enumerator.MoveNext()) count++; break;
										}
									}
									else
									{
										item6 = default;
									}
								}
								else
								{
									item6 = item5 = default;
								}
							}
							else
							{
								item6 = item5 = item4 = default;
							}
						}
						else
						{
							item6 = item5 = item4 = item3 = default;
						}
					}
					else
					{
						item6 = item5 = item4 = item3 = item2 = default;
					}
				}
				else
				{
					item6 = item5 = item4 = item3 = item2 = item1 = default;
				}
			}
			else
			{
				item6 = item5 = item4 = item3 = item2 = item1 = item0 = default;
			}
		}

		public static void Deconstruct(this IEnumerable<SwitchCase> list,
			out int count, out SwitchCase? item0, out SwitchCase? item1, out SwitchCase? item2, out SwitchCase? item3, out SwitchCase? item4, out SwitchCase? item5, out SwitchCase? item6, out SwitchCase? item7)
		{
			if (list == null) { count = -1; item0 = item1 = item2 = item3 = item4 = item5 = item6 = item7 = default; return; }

			count = 0;

			using var enumerator = list.GetEnumerator();

			if (enumerator.MoveNext())
			{
				count++;
				item0 = enumerator.Current;
	
				if (enumerator.MoveNext())
				{
					count++;
					item1 = enumerator.Current;
		
					if (enumerator.MoveNext())
					{
						count++;
						item2 = enumerator.Current;
			
						if (enumerator.MoveNext())
						{
							count++;
							item3 = enumerator.Current;
				
							if (enumerator.MoveNext())
							{
								count++;
								item4 = enumerator.Current;
					
								if (enumerator.MoveNext())
								{
									count++;
									item5 = enumerator.Current;
						
									if (enumerator.MoveNext())
									{
										count++;
										item6 = enumerator.Current;
							
										if (enumerator.MoveNext())
										{
											count++;
											item7 = enumerator.Current;
								
											switch (list)
											{
												case SwitchCase[]            arr : count = arr.Length; break;
												case ICollection<SwitchCase> col : count = col.Count;  break;
												default : if (enumerator.MoveNext()) count++; break;
											}
										}
										else
										{
											item7 = default;
										}
									}
									else
									{
										item7 = item6 = default;
									}
								}
								else
								{
									item7 = item6 = item5 = default;
								}
							}
							else
							{
								item7 = item6 = item5 = item4 = default;
							}
						}
						else
						{
							item7 = item6 = item5 = item4 = item3 = default;
						}
					}
					else
					{
						item7 = item6 = item5 = item4 = item3 = item2 = default;
					}
				}
				else
				{
					item7 = item6 = item5 = item4 = item3 = item2 = item1 = default;
				}
			}
			else
			{
				item7 = item6 = item5 = item4 = item3 = item2 = item1 = item0 = default;
			}
		}

		public static void Deconstruct(this IEnumerable<SwitchCase> list,
			out int count, out SwitchCase? item0, out SwitchCase? item1, out SwitchCase? item2, out SwitchCase? item3, out SwitchCase? item4, out SwitchCase? item5, out SwitchCase? item6, out SwitchCase? item7, out SwitchCase? item8)
		{
			if (list == null) { count = -1; item0 = item1 = item2 = item3 = item4 = item5 = item6 = item7 = item8 = default; return; }

			count = 0;

			using var enumerator = list.GetEnumerator();

			if (enumerator.MoveNext())
			{
				count++;
				item0 = enumerator.Current;
	
				if (enumerator.MoveNext())
				{
					count++;
					item1 = enumerator.Current;
		
					if (enumerator.MoveNext())
					{
						count++;
						item2 = enumerator.Current;
			
						if (enumerator.MoveNext())
						{
							count++;
							item3 = enumerator.Current;
				
							if (enumerator.MoveNext())
							{
								count++;
								item4 = enumerator.Current;
					
								if (enumerator.MoveNext())
								{
									count++;
									item5 = enumerator.Current;
						
									if (enumerator.MoveNext())
									{
										count++;
										item6 = enumerator.Current;
							
										if (enumerator.MoveNext())
										{
											count++;
											item7 = enumerator.Current;
								
											if (enumerator.MoveNext())
											{
												count++;
												item8 = enumerator.Current;
									
												switch (list)
												{
													case SwitchCase[]            arr : count = arr.Length; break;
													case ICollection<SwitchCase> col : count = col.Count;  break;
													default : if (enumerator.MoveNext()) count++; break;
												}
											}
											else
											{
												item8 = default;
											}
										}
										else
										{
											item8 = item7 = default;
										}
									}
									else
									{
										item8 = item7 = item6 = default;
									}
								}
								else
								{
									item8 = item7 = item6 = item5 = default;
								}
							}
							else
							{
								item8 = item7 = item6 = item5 = item4 = default;
							}
						}
						else
						{
							item8 = item7 = item6 = item5 = item4 = item3 = default;
						}
					}
					else
					{
						item8 = item7 = item6 = item5 = item4 = item3 = item2 = default;
					}
				}
				else
				{
					item8 = item7 = item6 = item5 = item4 = item3 = item2 = item1 = default;
				}
			}
			else
			{
				item8 = item7 = item6 = item5 = item4 = item3 = item2 = item1 = item0 = default;
			}
		}

		public static void Deconstruct(this IEnumerable<SwitchCase> list,
			out int count, out SwitchCase? item0, out SwitchCase? item1, out SwitchCase? item2, out SwitchCase? item3, out SwitchCase? item4, out SwitchCase? item5, out SwitchCase? item6, out SwitchCase? item7, out SwitchCase? item8, out SwitchCase? item9)
		{
			if (list == null) { count = -1; item0 = item1 = item2 = item3 = item4 = item5 = item6 = item7 = item8 = item9 = default; return; }

			count = 0;

			using var enumerator = list.GetEnumerator();

			if (enumerator.MoveNext())
			{
				count++;
				item0 = enumerator.Current;
	
				if (enumerator.MoveNext())
				{
					count++;
					item1 = enumerator.Current;
		
					if (enumerator.MoveNext())
					{
						count++;
						item2 = enumerator.Current;
			
						if (enumerator.MoveNext())
						{
							count++;
							item3 = enumerator.Current;
				
							if (enumerator.MoveNext())
							{
								count++;
								item4 = enumerator.Current;
					
								if (enumerator.MoveNext())
								{
									count++;
									item5 = enumerator.Current;
						
									if (enumerator.MoveNext())
									{
										count++;
										item6 = enumerator.Current;
							
										if (enumerator.MoveNext())
										{
											count++;
											item7 = enumerator.Current;
								
											if (enumerator.MoveNext())
											{
												count++;
												item8 = enumerator.Current;
									
												if (enumerator.MoveNext())
												{
													count++;
													item9 = enumerator.Current;
										
													switch (list)
													{
														case SwitchCase[]            arr : count = arr.Length; break;
														case ICollection<SwitchCase> col : count = col.Count;  break;
														default : if (enumerator.MoveNext()) count++; break;
													}
												}
												else
												{
													item9 = default;
												}
											}
											else
											{
												item9 = item8 = default;
											}
										}
										else
										{
											item9 = item8 = item7 = default;
										}
									}
									else
									{
										item9 = item8 = item7 = item6 = default;
									}
								}
								else
								{
									item9 = item8 = item7 = item6 = item5 = default;
								}
							}
							else
							{
								item9 = item8 = item7 = item6 = item5 = item4 = default;
							}
						}
						else
						{
							item9 = item8 = item7 = item6 = item5 = item4 = item3 = default;
						}
					}
					else
					{
						item9 = item8 = item7 = item6 = item5 = item4 = item3 = item2 = default;
					}
				}
				else
				{
					item9 = item8 = item7 = item6 = item5 = item4 = item3 = item2 = item1 = default;
				}
			}
			else
			{
				item9 = item8 = item7 = item6 = item5 = item4 = item3 = item2 = item1 = item0 = default;
			}
		}

		#endregion

		#region IEnumerable<MemberBinding>

		public static void Deconstruct(this IEnumerable<MemberBinding> list, out int count)
		{
			switch (list)
			{
				case MemberBinding[]            arr : count = arr.Length; break;
				case ICollection<MemberBinding> col : count = col.Count;  break;
				case null : count = -1; break;
				default   :
					using (var enumerator = list.GetEnumerator())
						count = enumerator.MoveNext() ? 1 : 0;
					break;
			}
		}

		public static void Deconstruct(this IEnumerable<MemberBinding> list,
			out int count, out MemberBinding? item0)
		{
			if (list == null) { count = -1; item0 = default; return; }

			count = 0;

			using var enumerator = list.GetEnumerator();

			if (enumerator.MoveNext())
			{
				count++;
				item0 = enumerator.Current;
	
				switch (list)
				{
					case MemberBinding[]            arr : count = arr.Length; break;
					case ICollection<MemberBinding> col : count = col.Count;  break;
					default : if (enumerator.MoveNext()) count++; break;
				}
			}
			else
			{
				item0 = default;
			}
		}

		public static void Deconstruct(this IEnumerable<MemberBinding> list,
			out int count, out MemberBinding? item0, out MemberBinding? item1)
		{
			if (list == null) { count = -1; item0 = item1 = default; return; }

			count = 0;

			using var enumerator = list.GetEnumerator();

			if (enumerator.MoveNext())
			{
				count++;
				item0 = enumerator.Current;
	
				if (enumerator.MoveNext())
				{
					count++;
					item1 = enumerator.Current;
		
					switch (list)
					{
						case MemberBinding[]            arr : count = arr.Length; break;
						case ICollection<MemberBinding> col : count = col.Count;  break;
						default : if (enumerator.MoveNext()) count++; break;
					}
				}
				else
				{
					item1 = default;
				}
			}
			else
			{
				item1 = item0 = default;
			}
		}

		public static void Deconstruct(this IEnumerable<MemberBinding> list,
			out int count, out MemberBinding? item0, out MemberBinding? item1, out MemberBinding? item2)
		{
			if (list == null) { count = -1; item0 = item1 = item2 = default; return; }

			count = 0;

			using var enumerator = list.GetEnumerator();

			if (enumerator.MoveNext())
			{
				count++;
				item0 = enumerator.Current;
	
				if (enumerator.MoveNext())
				{
					count++;
					item1 = enumerator.Current;
		
					if (enumerator.MoveNext())
					{
						count++;
						item2 = enumerator.Current;
			
						switch (list)
						{
							case MemberBinding[]            arr : count = arr.Length; break;
							case ICollection<MemberBinding> col : count = col.Count;  break;
							default : if (enumerator.MoveNext()) count++; break;
						}
					}
					else
					{
						item2 = default;
					}
				}
				else
				{
					item2 = item1 = default;
				}
			}
			else
			{
				item2 = item1 = item0 = default;
			}
		}

		public static void Deconstruct(this IEnumerable<MemberBinding> list,
			out int count, out MemberBinding? item0, out MemberBinding? item1, out MemberBinding? item2, out MemberBinding? item3)
		{
			if (list == null) { count = -1; item0 = item1 = item2 = item3 = default; return; }

			count = 0;

			using var enumerator = list.GetEnumerator();

			if (enumerator.MoveNext())
			{
				count++;
				item0 = enumerator.Current;
	
				if (enumerator.MoveNext())
				{
					count++;
					item1 = enumerator.Current;
		
					if (enumerator.MoveNext())
					{
						count++;
						item2 = enumerator.Current;
			
						if (enumerator.MoveNext())
						{
							count++;
							item3 = enumerator.Current;
				
							switch (list)
							{
								case MemberBinding[]            arr : count = arr.Length; break;
								case ICollection<MemberBinding> col : count = col.Count;  break;
								default : if (enumerator.MoveNext()) count++; break;
							}
						}
						else
						{
							item3 = default;
						}
					}
					else
					{
						item3 = item2 = default;
					}
				}
				else
				{
					item3 = item2 = item1 = default;
				}
			}
			else
			{
				item3 = item2 = item1 = item0 = default;
			}
		}

		public static void Deconstruct(this IEnumerable<MemberBinding> list,
			out int count, out MemberBinding? item0, out MemberBinding? item1, out MemberBinding? item2, out MemberBinding? item3, out MemberBinding? item4)
		{
			if (list == null) { count = -1; item0 = item1 = item2 = item3 = item4 = default; return; }

			count = 0;

			using var enumerator = list.GetEnumerator();

			if (enumerator.MoveNext())
			{
				count++;
				item0 = enumerator.Current;
	
				if (enumerator.MoveNext())
				{
					count++;
					item1 = enumerator.Current;
		
					if (enumerator.MoveNext())
					{
						count++;
						item2 = enumerator.Current;
			
						if (enumerator.MoveNext())
						{
							count++;
							item3 = enumerator.Current;
				
							if (enumerator.MoveNext())
							{
								count++;
								item4 = enumerator.Current;
					
								switch (list)
								{
									case MemberBinding[]            arr : count = arr.Length; break;
									case ICollection<MemberBinding> col : count = col.Count;  break;
									default : if (enumerator.MoveNext()) count++; break;
								}
							}
							else
							{
								item4 = default;
							}
						}
						else
						{
							item4 = item3 = default;
						}
					}
					else
					{
						item4 = item3 = item2 = default;
					}
				}
				else
				{
					item4 = item3 = item2 = item1 = default;
				}
			}
			else
			{
				item4 = item3 = item2 = item1 = item0 = default;
			}
		}

		public static void Deconstruct(this IEnumerable<MemberBinding> list,
			out int count, out MemberBinding? item0, out MemberBinding? item1, out MemberBinding? item2, out MemberBinding? item3, out MemberBinding? item4, out MemberBinding? item5)
		{
			if (list == null) { count = -1; item0 = item1 = item2 = item3 = item4 = item5 = default; return; }

			count = 0;

			using var enumerator = list.GetEnumerator();

			if (enumerator.MoveNext())
			{
				count++;
				item0 = enumerator.Current;
	
				if (enumerator.MoveNext())
				{
					count++;
					item1 = enumerator.Current;
		
					if (enumerator.MoveNext())
					{
						count++;
						item2 = enumerator.Current;
			
						if (enumerator.MoveNext())
						{
							count++;
							item3 = enumerator.Current;
				
							if (enumerator.MoveNext())
							{
								count++;
								item4 = enumerator.Current;
					
								if (enumerator.MoveNext())
								{
									count++;
									item5 = enumerator.Current;
						
									switch (list)
									{
										case MemberBinding[]            arr : count = arr.Length; break;
										case ICollection<MemberBinding> col : count = col.Count;  break;
										default : if (enumerator.MoveNext()) count++; break;
									}
								}
								else
								{
									item5 = default;
								}
							}
							else
							{
								item5 = item4 = default;
							}
						}
						else
						{
							item5 = item4 = item3 = default;
						}
					}
					else
					{
						item5 = item4 = item3 = item2 = default;
					}
				}
				else
				{
					item5 = item4 = item3 = item2 = item1 = default;
				}
			}
			else
			{
				item5 = item4 = item3 = item2 = item1 = item0 = default;
			}
		}

		public static void Deconstruct(this IEnumerable<MemberBinding> list,
			out int count, out MemberBinding? item0, out MemberBinding? item1, out MemberBinding? item2, out MemberBinding? item3, out MemberBinding? item4, out MemberBinding? item5, out MemberBinding? item6)
		{
			if (list == null) { count = -1; item0 = item1 = item2 = item3 = item4 = item5 = item6 = default; return; }

			count = 0;

			using var enumerator = list.GetEnumerator();

			if (enumerator.MoveNext())
			{
				count++;
				item0 = enumerator.Current;
	
				if (enumerator.MoveNext())
				{
					count++;
					item1 = enumerator.Current;
		
					if (enumerator.MoveNext())
					{
						count++;
						item2 = enumerator.Current;
			
						if (enumerator.MoveNext())
						{
							count++;
							item3 = enumerator.Current;
				
							if (enumerator.MoveNext())
							{
								count++;
								item4 = enumerator.Current;
					
								if (enumerator.MoveNext())
								{
									count++;
									item5 = enumerator.Current;
						
									if (enumerator.MoveNext())
									{
										count++;
										item6 = enumerator.Current;
							
										switch (list)
										{
											case MemberBinding[]            arr : count = arr.Length; break;
											case ICollection<MemberBinding> col : count = col.Count;  break;
											default : if (enumerator.MoveNext()) count++; break;
										}
									}
									else
									{
										item6 = default;
									}
								}
								else
								{
									item6 = item5 = default;
								}
							}
							else
							{
								item6 = item5 = item4 = default;
							}
						}
						else
						{
							item6 = item5 = item4 = item3 = default;
						}
					}
					else
					{
						item6 = item5 = item4 = item3 = item2 = default;
					}
				}
				else
				{
					item6 = item5 = item4 = item3 = item2 = item1 = default;
				}
			}
			else
			{
				item6 = item5 = item4 = item3 = item2 = item1 = item0 = default;
			}
		}

		public static void Deconstruct(this IEnumerable<MemberBinding> list,
			out int count, out MemberBinding? item0, out MemberBinding? item1, out MemberBinding? item2, out MemberBinding? item3, out MemberBinding? item4, out MemberBinding? item5, out MemberBinding? item6, out MemberBinding? item7)
		{
			if (list == null) { count = -1; item0 = item1 = item2 = item3 = item4 = item5 = item6 = item7 = default; return; }

			count = 0;

			using var enumerator = list.GetEnumerator();

			if (enumerator.MoveNext())
			{
				count++;
				item0 = enumerator.Current;
	
				if (enumerator.MoveNext())
				{
					count++;
					item1 = enumerator.Current;
		
					if (enumerator.MoveNext())
					{
						count++;
						item2 = enumerator.Current;
			
						if (enumerator.MoveNext())
						{
							count++;
							item3 = enumerator.Current;
				
							if (enumerator.MoveNext())
							{
								count++;
								item4 = enumerator.Current;
					
								if (enumerator.MoveNext())
								{
									count++;
									item5 = enumerator.Current;
						
									if (enumerator.MoveNext())
									{
										count++;
										item6 = enumerator.Current;
							
										if (enumerator.MoveNext())
										{
											count++;
											item7 = enumerator.Current;
								
											switch (list)
											{
												case MemberBinding[]            arr : count = arr.Length; break;
												case ICollection<MemberBinding> col : count = col.Count;  break;
												default : if (enumerator.MoveNext()) count++; break;
											}
										}
										else
										{
											item7 = default;
										}
									}
									else
									{
										item7 = item6 = default;
									}
								}
								else
								{
									item7 = item6 = item5 = default;
								}
							}
							else
							{
								item7 = item6 = item5 = item4 = default;
							}
						}
						else
						{
							item7 = item6 = item5 = item4 = item3 = default;
						}
					}
					else
					{
						item7 = item6 = item5 = item4 = item3 = item2 = default;
					}
				}
				else
				{
					item7 = item6 = item5 = item4 = item3 = item2 = item1 = default;
				}
			}
			else
			{
				item7 = item6 = item5 = item4 = item3 = item2 = item1 = item0 = default;
			}
		}

		public static void Deconstruct(this IEnumerable<MemberBinding> list,
			out int count, out MemberBinding? item0, out MemberBinding? item1, out MemberBinding? item2, out MemberBinding? item3, out MemberBinding? item4, out MemberBinding? item5, out MemberBinding? item6, out MemberBinding? item7, out MemberBinding? item8)
		{
			if (list == null) { count = -1; item0 = item1 = item2 = item3 = item4 = item5 = item6 = item7 = item8 = default; return; }

			count = 0;

			using var enumerator = list.GetEnumerator();

			if (enumerator.MoveNext())
			{
				count++;
				item0 = enumerator.Current;
	
				if (enumerator.MoveNext())
				{
					count++;
					item1 = enumerator.Current;
		
					if (enumerator.MoveNext())
					{
						count++;
						item2 = enumerator.Current;
			
						if (enumerator.MoveNext())
						{
							count++;
							item3 = enumerator.Current;
				
							if (enumerator.MoveNext())
							{
								count++;
								item4 = enumerator.Current;
					
								if (enumerator.MoveNext())
								{
									count++;
									item5 = enumerator.Current;
						
									if (enumerator.MoveNext())
									{
										count++;
										item6 = enumerator.Current;
							
										if (enumerator.MoveNext())
										{
											count++;
											item7 = enumerator.Current;
								
											if (enumerator.MoveNext())
											{
												count++;
												item8 = enumerator.Current;
									
												switch (list)
												{
													case MemberBinding[]            arr : count = arr.Length; break;
													case ICollection<MemberBinding> col : count = col.Count;  break;
													default : if (enumerator.MoveNext()) count++; break;
												}
											}
											else
											{
												item8 = default;
											}
										}
										else
										{
											item8 = item7 = default;
										}
									}
									else
									{
										item8 = item7 = item6 = default;
									}
								}
								else
								{
									item8 = item7 = item6 = item5 = default;
								}
							}
							else
							{
								item8 = item7 = item6 = item5 = item4 = default;
							}
						}
						else
						{
							item8 = item7 = item6 = item5 = item4 = item3 = default;
						}
					}
					else
					{
						item8 = item7 = item6 = item5 = item4 = item3 = item2 = default;
					}
				}
				else
				{
					item8 = item7 = item6 = item5 = item4 = item3 = item2 = item1 = default;
				}
			}
			else
			{
				item8 = item7 = item6 = item5 = item4 = item3 = item2 = item1 = item0 = default;
			}
		}

		public static void Deconstruct(this IEnumerable<MemberBinding> list,
			out int count, out MemberBinding? item0, out MemberBinding? item1, out MemberBinding? item2, out MemberBinding? item3, out MemberBinding? item4, out MemberBinding? item5, out MemberBinding? item6, out MemberBinding? item7, out MemberBinding? item8, out MemberBinding? item9)
		{
			if (list == null) { count = -1; item0 = item1 = item2 = item3 = item4 = item5 = item6 = item7 = item8 = item9 = default; return; }

			count = 0;

			using var enumerator = list.GetEnumerator();

			if (enumerator.MoveNext())
			{
				count++;
				item0 = enumerator.Current;
	
				if (enumerator.MoveNext())
				{
					count++;
					item1 = enumerator.Current;
		
					if (enumerator.MoveNext())
					{
						count++;
						item2 = enumerator.Current;
			
						if (enumerator.MoveNext())
						{
							count++;
							item3 = enumerator.Current;
				
							if (enumerator.MoveNext())
							{
								count++;
								item4 = enumerator.Current;
					
								if (enumerator.MoveNext())
								{
									count++;
									item5 = enumerator.Current;
						
									if (enumerator.MoveNext())
									{
										count++;
										item6 = enumerator.Current;
							
										if (enumerator.MoveNext())
										{
											count++;
											item7 = enumerator.Current;
								
											if (enumerator.MoveNext())
											{
												count++;
												item8 = enumerator.Current;
									
												if (enumerator.MoveNext())
												{
													count++;
													item9 = enumerator.Current;
										
													switch (list)
													{
														case MemberBinding[]            arr : count = arr.Length; break;
														case ICollection<MemberBinding> col : count = col.Count;  break;
														default : if (enumerator.MoveNext()) count++; break;
													}
												}
												else
												{
													item9 = default;
												}
											}
											else
											{
												item9 = item8 = default;
											}
										}
										else
										{
											item9 = item8 = item7 = default;
										}
									}
									else
									{
										item9 = item8 = item7 = item6 = default;
									}
								}
								else
								{
									item9 = item8 = item7 = item6 = item5 = default;
								}
							}
							else
							{
								item9 = item8 = item7 = item6 = item5 = item4 = default;
							}
						}
						else
						{
							item9 = item8 = item7 = item6 = item5 = item4 = item3 = default;
						}
					}
					else
					{
						item9 = item8 = item7 = item6 = item5 = item4 = item3 = item2 = default;
					}
				}
				else
				{
					item9 = item8 = item7 = item6 = item5 = item4 = item3 = item2 = item1 = default;
				}
			}
			else
			{
				item9 = item8 = item7 = item6 = item5 = item4 = item3 = item2 = item1 = item0 = default;
			}
		}

		#endregion

		#region IEnumerable<MemberInfo>

		public static void Deconstruct(this IEnumerable<MemberInfo> list, out int count)
		{
			switch (list)
			{
				case MemberInfo[]            arr : count = arr.Length; break;
				case ICollection<MemberInfo> col : count = col.Count;  break;
				case null : count = -1; break;
				default   :
					using (var enumerator = list.GetEnumerator())
						count = enumerator.MoveNext() ? 1 : 0;
					break;
			}
		}

		public static void Deconstruct(this IEnumerable<MemberInfo> list,
			out int count, out MemberInfo? item0)
		{
			if (list == null) { count = -1; item0 = default; return; }

			count = 0;

			using var enumerator = list.GetEnumerator();

			if (enumerator.MoveNext())
			{
				count++;
				item0 = enumerator.Current;
	
				switch (list)
				{
					case MemberInfo[]            arr : count = arr.Length; break;
					case ICollection<MemberInfo> col : count = col.Count;  break;
					default : if (enumerator.MoveNext()) count++; break;
				}
			}
			else
			{
				item0 = default;
			}
		}

		public static void Deconstruct(this IEnumerable<MemberInfo> list,
			out int count, out MemberInfo? item0, out MemberInfo? item1)
		{
			if (list == null) { count = -1; item0 = item1 = default; return; }

			count = 0;

			using var enumerator = list.GetEnumerator();

			if (enumerator.MoveNext())
			{
				count++;
				item0 = enumerator.Current;
	
				if (enumerator.MoveNext())
				{
					count++;
					item1 = enumerator.Current;
		
					switch (list)
					{
						case MemberInfo[]            arr : count = arr.Length; break;
						case ICollection<MemberInfo> col : count = col.Count;  break;
						default : if (enumerator.MoveNext()) count++; break;
					}
				}
				else
				{
					item1 = default;
				}
			}
			else
			{
				item1 = item0 = default;
			}
		}

		public static void Deconstruct(this IEnumerable<MemberInfo> list,
			out int count, out MemberInfo? item0, out MemberInfo? item1, out MemberInfo? item2)
		{
			if (list == null) { count = -1; item0 = item1 = item2 = default; return; }

			count = 0;

			using var enumerator = list.GetEnumerator();

			if (enumerator.MoveNext())
			{
				count++;
				item0 = enumerator.Current;
	
				if (enumerator.MoveNext())
				{
					count++;
					item1 = enumerator.Current;
		
					if (enumerator.MoveNext())
					{
						count++;
						item2 = enumerator.Current;
			
						switch (list)
						{
							case MemberInfo[]            arr : count = arr.Length; break;
							case ICollection<MemberInfo> col : count = col.Count;  break;
							default : if (enumerator.MoveNext()) count++; break;
						}
					}
					else
					{
						item2 = default;
					}
				}
				else
				{
					item2 = item1 = default;
				}
			}
			else
			{
				item2 = item1 = item0 = default;
			}
		}

		public static void Deconstruct(this IEnumerable<MemberInfo> list,
			out int count, out MemberInfo? item0, out MemberInfo? item1, out MemberInfo? item2, out MemberInfo? item3)
		{
			if (list == null) { count = -1; item0 = item1 = item2 = item3 = default; return; }

			count = 0;

			using var enumerator = list.GetEnumerator();

			if (enumerator.MoveNext())
			{
				count++;
				item0 = enumerator.Current;
	
				if (enumerator.MoveNext())
				{
					count++;
					item1 = enumerator.Current;
		
					if (enumerator.MoveNext())
					{
						count++;
						item2 = enumerator.Current;
			
						if (enumerator.MoveNext())
						{
							count++;
							item3 = enumerator.Current;
				
							switch (list)
							{
								case MemberInfo[]            arr : count = arr.Length; break;
								case ICollection<MemberInfo> col : count = col.Count;  break;
								default : if (enumerator.MoveNext()) count++; break;
							}
						}
						else
						{
							item3 = default;
						}
					}
					else
					{
						item3 = item2 = default;
					}
				}
				else
				{
					item3 = item2 = item1 = default;
				}
			}
			else
			{
				item3 = item2 = item1 = item0 = default;
			}
		}

		public static void Deconstruct(this IEnumerable<MemberInfo> list,
			out int count, out MemberInfo? item0, out MemberInfo? item1, out MemberInfo? item2, out MemberInfo? item3, out MemberInfo? item4)
		{
			if (list == null) { count = -1; item0 = item1 = item2 = item3 = item4 = default; return; }

			count = 0;

			using var enumerator = list.GetEnumerator();

			if (enumerator.MoveNext())
			{
				count++;
				item0 = enumerator.Current;
	
				if (enumerator.MoveNext())
				{
					count++;
					item1 = enumerator.Current;
		
					if (enumerator.MoveNext())
					{
						count++;
						item2 = enumerator.Current;
			
						if (enumerator.MoveNext())
						{
							count++;
							item3 = enumerator.Current;
				
							if (enumerator.MoveNext())
							{
								count++;
								item4 = enumerator.Current;
					
								switch (list)
								{
									case MemberInfo[]            arr : count = arr.Length; break;
									case ICollection<MemberInfo> col : count = col.Count;  break;
									default : if (enumerator.MoveNext()) count++; break;
								}
							}
							else
							{
								item4 = default;
							}
						}
						else
						{
							item4 = item3 = default;
						}
					}
					else
					{
						item4 = item3 = item2 = default;
					}
				}
				else
				{
					item4 = item3 = item2 = item1 = default;
				}
			}
			else
			{
				item4 = item3 = item2 = item1 = item0 = default;
			}
		}

		public static void Deconstruct(this IEnumerable<MemberInfo> list,
			out int count, out MemberInfo? item0, out MemberInfo? item1, out MemberInfo? item2, out MemberInfo? item3, out MemberInfo? item4, out MemberInfo? item5)
		{
			if (list == null) { count = -1; item0 = item1 = item2 = item3 = item4 = item5 = default; return; }

			count = 0;

			using var enumerator = list.GetEnumerator();

			if (enumerator.MoveNext())
			{
				count++;
				item0 = enumerator.Current;
	
				if (enumerator.MoveNext())
				{
					count++;
					item1 = enumerator.Current;
		
					if (enumerator.MoveNext())
					{
						count++;
						item2 = enumerator.Current;
			
						if (enumerator.MoveNext())
						{
							count++;
							item3 = enumerator.Current;
				
							if (enumerator.MoveNext())
							{
								count++;
								item4 = enumerator.Current;
					
								if (enumerator.MoveNext())
								{
									count++;
									item5 = enumerator.Current;
						
									switch (list)
									{
										case MemberInfo[]            arr : count = arr.Length; break;
										case ICollection<MemberInfo> col : count = col.Count;  break;
										default : if (enumerator.MoveNext()) count++; break;
									}
								}
								else
								{
									item5 = default;
								}
							}
							else
							{
								item5 = item4 = default;
							}
						}
						else
						{
							item5 = item4 = item3 = default;
						}
					}
					else
					{
						item5 = item4 = item3 = item2 = default;
					}
				}
				else
				{
					item5 = item4 = item3 = item2 = item1 = default;
				}
			}
			else
			{
				item5 = item4 = item3 = item2 = item1 = item0 = default;
			}
		}

		public static void Deconstruct(this IEnumerable<MemberInfo> list,
			out int count, out MemberInfo? item0, out MemberInfo? item1, out MemberInfo? item2, out MemberInfo? item3, out MemberInfo? item4, out MemberInfo? item5, out MemberInfo? item6)
		{
			if (list == null) { count = -1; item0 = item1 = item2 = item3 = item4 = item5 = item6 = default; return; }

			count = 0;

			using var enumerator = list.GetEnumerator();

			if (enumerator.MoveNext())
			{
				count++;
				item0 = enumerator.Current;
	
				if (enumerator.MoveNext())
				{
					count++;
					item1 = enumerator.Current;
		
					if (enumerator.MoveNext())
					{
						count++;
						item2 = enumerator.Current;
			
						if (enumerator.MoveNext())
						{
							count++;
							item3 = enumerator.Current;
				
							if (enumerator.MoveNext())
							{
								count++;
								item4 = enumerator.Current;
					
								if (enumerator.MoveNext())
								{
									count++;
									item5 = enumerator.Current;
						
									if (enumerator.MoveNext())
									{
										count++;
										item6 = enumerator.Current;
							
										switch (list)
										{
											case MemberInfo[]            arr : count = arr.Length; break;
											case ICollection<MemberInfo> col : count = col.Count;  break;
											default : if (enumerator.MoveNext()) count++; break;
										}
									}
									else
									{
										item6 = default;
									}
								}
								else
								{
									item6 = item5 = default;
								}
							}
							else
							{
								item6 = item5 = item4 = default;
							}
						}
						else
						{
							item6 = item5 = item4 = item3 = default;
						}
					}
					else
					{
						item6 = item5 = item4 = item3 = item2 = default;
					}
				}
				else
				{
					item6 = item5 = item4 = item3 = item2 = item1 = default;
				}
			}
			else
			{
				item6 = item5 = item4 = item3 = item2 = item1 = item0 = default;
			}
		}

		public static void Deconstruct(this IEnumerable<MemberInfo> list,
			out int count, out MemberInfo? item0, out MemberInfo? item1, out MemberInfo? item2, out MemberInfo? item3, out MemberInfo? item4, out MemberInfo? item5, out MemberInfo? item6, out MemberInfo? item7)
		{
			if (list == null) { count = -1; item0 = item1 = item2 = item3 = item4 = item5 = item6 = item7 = default; return; }

			count = 0;

			using var enumerator = list.GetEnumerator();

			if (enumerator.MoveNext())
			{
				count++;
				item0 = enumerator.Current;
	
				if (enumerator.MoveNext())
				{
					count++;
					item1 = enumerator.Current;
		
					if (enumerator.MoveNext())
					{
						count++;
						item2 = enumerator.Current;
			
						if (enumerator.MoveNext())
						{
							count++;
							item3 = enumerator.Current;
				
							if (enumerator.MoveNext())
							{
								count++;
								item4 = enumerator.Current;
					
								if (enumerator.MoveNext())
								{
									count++;
									item5 = enumerator.Current;
						
									if (enumerator.MoveNext())
									{
										count++;
										item6 = enumerator.Current;
							
										if (enumerator.MoveNext())
										{
											count++;
											item7 = enumerator.Current;
								
											switch (list)
											{
												case MemberInfo[]            arr : count = arr.Length; break;
												case ICollection<MemberInfo> col : count = col.Count;  break;
												default : if (enumerator.MoveNext()) count++; break;
											}
										}
										else
										{
											item7 = default;
										}
									}
									else
									{
										item7 = item6 = default;
									}
								}
								else
								{
									item7 = item6 = item5 = default;
								}
							}
							else
							{
								item7 = item6 = item5 = item4 = default;
							}
						}
						else
						{
							item7 = item6 = item5 = item4 = item3 = default;
						}
					}
					else
					{
						item7 = item6 = item5 = item4 = item3 = item2 = default;
					}
				}
				else
				{
					item7 = item6 = item5 = item4 = item3 = item2 = item1 = default;
				}
			}
			else
			{
				item7 = item6 = item5 = item4 = item3 = item2 = item1 = item0 = default;
			}
		}

		public static void Deconstruct(this IEnumerable<MemberInfo> list,
			out int count, out MemberInfo? item0, out MemberInfo? item1, out MemberInfo? item2, out MemberInfo? item3, out MemberInfo? item4, out MemberInfo? item5, out MemberInfo? item6, out MemberInfo? item7, out MemberInfo? item8)
		{
			if (list == null) { count = -1; item0 = item1 = item2 = item3 = item4 = item5 = item6 = item7 = item8 = default; return; }

			count = 0;

			using var enumerator = list.GetEnumerator();

			if (enumerator.MoveNext())
			{
				count++;
				item0 = enumerator.Current;
	
				if (enumerator.MoveNext())
				{
					count++;
					item1 = enumerator.Current;
		
					if (enumerator.MoveNext())
					{
						count++;
						item2 = enumerator.Current;
			
						if (enumerator.MoveNext())
						{
							count++;
							item3 = enumerator.Current;
				
							if (enumerator.MoveNext())
							{
								count++;
								item4 = enumerator.Current;
					
								if (enumerator.MoveNext())
								{
									count++;
									item5 = enumerator.Current;
						
									if (enumerator.MoveNext())
									{
										count++;
										item6 = enumerator.Current;
							
										if (enumerator.MoveNext())
										{
											count++;
											item7 = enumerator.Current;
								
											if (enumerator.MoveNext())
											{
												count++;
												item8 = enumerator.Current;
									
												switch (list)
												{
													case MemberInfo[]            arr : count = arr.Length; break;
													case ICollection<MemberInfo> col : count = col.Count;  break;
													default : if (enumerator.MoveNext()) count++; break;
												}
											}
											else
											{
												item8 = default;
											}
										}
										else
										{
											item8 = item7 = default;
										}
									}
									else
									{
										item8 = item7 = item6 = default;
									}
								}
								else
								{
									item8 = item7 = item6 = item5 = default;
								}
							}
							else
							{
								item8 = item7 = item6 = item5 = item4 = default;
							}
						}
						else
						{
							item8 = item7 = item6 = item5 = item4 = item3 = default;
						}
					}
					else
					{
						item8 = item7 = item6 = item5 = item4 = item3 = item2 = default;
					}
				}
				else
				{
					item8 = item7 = item6 = item5 = item4 = item3 = item2 = item1 = default;
				}
			}
			else
			{
				item8 = item7 = item6 = item5 = item4 = item3 = item2 = item1 = item0 = default;
			}
		}

		public static void Deconstruct(this IEnumerable<MemberInfo> list,
			out int count, out MemberInfo? item0, out MemberInfo? item1, out MemberInfo? item2, out MemberInfo? item3, out MemberInfo? item4, out MemberInfo? item5, out MemberInfo? item6, out MemberInfo? item7, out MemberInfo? item8, out MemberInfo? item9)
		{
			if (list == null) { count = -1; item0 = item1 = item2 = item3 = item4 = item5 = item6 = item7 = item8 = item9 = default; return; }

			count = 0;

			using var enumerator = list.GetEnumerator();

			if (enumerator.MoveNext())
			{
				count++;
				item0 = enumerator.Current;
	
				if (enumerator.MoveNext())
				{
					count++;
					item1 = enumerator.Current;
		
					if (enumerator.MoveNext())
					{
						count++;
						item2 = enumerator.Current;
			
						if (enumerator.MoveNext())
						{
							count++;
							item3 = enumerator.Current;
				
							if (enumerator.MoveNext())
							{
								count++;
								item4 = enumerator.Current;
					
								if (enumerator.MoveNext())
								{
									count++;
									item5 = enumerator.Current;
						
									if (enumerator.MoveNext())
									{
										count++;
										item6 = enumerator.Current;
							
										if (enumerator.MoveNext())
										{
											count++;
											item7 = enumerator.Current;
								
											if (enumerator.MoveNext())
											{
												count++;
												item8 = enumerator.Current;
									
												if (enumerator.MoveNext())
												{
													count++;
													item9 = enumerator.Current;
										
													switch (list)
													{
														case MemberInfo[]            arr : count = arr.Length; break;
														case ICollection<MemberInfo> col : count = col.Count;  break;
														default : if (enumerator.MoveNext()) count++; break;
													}
												}
												else
												{
													item9 = default;
												}
											}
											else
											{
												item9 = item8 = default;
											}
										}
										else
										{
											item9 = item8 = item7 = default;
										}
									}
									else
									{
										item9 = item8 = item7 = item6 = default;
									}
								}
								else
								{
									item9 = item8 = item7 = item6 = item5 = default;
								}
							}
							else
							{
								item9 = item8 = item7 = item6 = item5 = item4 = default;
							}
						}
						else
						{
							item9 = item8 = item7 = item6 = item5 = item4 = item3 = default;
						}
					}
					else
					{
						item9 = item8 = item7 = item6 = item5 = item4 = item3 = item2 = default;
					}
				}
				else
				{
					item9 = item8 = item7 = item6 = item5 = item4 = item3 = item2 = item1 = default;
				}
			}
			else
			{
				item9 = item8 = item7 = item6 = item5 = item4 = item3 = item2 = item1 = item0 = default;
			}
		}

		#endregion

		#region IEnumerable<Expression>

		public static void Deconstruct(this IEnumerable<Expression> list, out int count)
		{
			switch (list)
			{
				case Expression[]            arr : count = arr.Length; break;
				case ICollection<Expression> col : count = col.Count;  break;
				case null : count = -1; break;
				default   :
					using (var enumerator = list.GetEnumerator())
						count = enumerator.MoveNext() ? 1 : 0;
					break;
			}
		}

		public static void Deconstruct(this IEnumerable<Expression> list,
			out int count, out Expr? item0)
		{
			if (list == null) { count = -1; item0 = default; return; }

			count = 0;

			using var enumerator = list.GetEnumerator();

			if (enumerator.MoveNext())
			{
				count++;
				item0 = enumerator.Current.ToExpr();
	
				switch (list)
				{
					case Expression[]            arr : count = arr.Length; break;
					case ICollection<Expression> col : count = col.Count;  break;
					default : if (enumerator.MoveNext()) count++; break;
				}
			}
			else
			{
				item0 = default;
			}
		}

		public static void Deconstruct(this IEnumerable<Expression> list,
			out int count, out Expr? item0, out Expr? item1)
		{
			if (list == null) { count = -1; item0 = item1 = default; return; }

			count = 0;

			using var enumerator = list.GetEnumerator();

			if (enumerator.MoveNext())
			{
				count++;
				item0 = enumerator.Current.ToExpr();
	
				if (enumerator.MoveNext())
				{
					count++;
					item1 = enumerator.Current.ToExpr();
		
					switch (list)
					{
						case Expression[]            arr : count = arr.Length; break;
						case ICollection<Expression> col : count = col.Count;  break;
						default : if (enumerator.MoveNext()) count++; break;
					}
				}
				else
				{
					item1 = default;
				}
			}
			else
			{
				item1 = item0 = default;
			}
		}

		public static void Deconstruct(this IEnumerable<Expression> list,
			out int count, out Expr? item0, out Expr? item1, out Expr? item2)
		{
			if (list == null) { count = -1; item0 = item1 = item2 = default; return; }

			count = 0;

			using var enumerator = list.GetEnumerator();

			if (enumerator.MoveNext())
			{
				count++;
				item0 = enumerator.Current.ToExpr();
	
				if (enumerator.MoveNext())
				{
					count++;
					item1 = enumerator.Current.ToExpr();
		
					if (enumerator.MoveNext())
					{
						count++;
						item2 = enumerator.Current.ToExpr();
			
						switch (list)
						{
							case Expression[]            arr : count = arr.Length; break;
							case ICollection<Expression> col : count = col.Count;  break;
							default : if (enumerator.MoveNext()) count++; break;
						}
					}
					else
					{
						item2 = default;
					}
				}
				else
				{
					item2 = item1 = default;
				}
			}
			else
			{
				item2 = item1 = item0 = default;
			}
		}

		public static void Deconstruct(this IEnumerable<Expression> list,
			out int count, out Expr? item0, out Expr? item1, out Expr? item2, out Expr? item3)
		{
			if (list == null) { count = -1; item0 = item1 = item2 = item3 = default; return; }

			count = 0;

			using var enumerator = list.GetEnumerator();

			if (enumerator.MoveNext())
			{
				count++;
				item0 = enumerator.Current.ToExpr();
	
				if (enumerator.MoveNext())
				{
					count++;
					item1 = enumerator.Current.ToExpr();
		
					if (enumerator.MoveNext())
					{
						count++;
						item2 = enumerator.Current.ToExpr();
			
						if (enumerator.MoveNext())
						{
							count++;
							item3 = enumerator.Current.ToExpr();
				
							switch (list)
							{
								case Expression[]            arr : count = arr.Length; break;
								case ICollection<Expression> col : count = col.Count;  break;
								default : if (enumerator.MoveNext()) count++; break;
							}
						}
						else
						{
							item3 = default;
						}
					}
					else
					{
						item3 = item2 = default;
					}
				}
				else
				{
					item3 = item2 = item1 = default;
				}
			}
			else
			{
				item3 = item2 = item1 = item0 = default;
			}
		}

		public static void Deconstruct(this IEnumerable<Expression> list,
			out int count, out Expr? item0, out Expr? item1, out Expr? item2, out Expr? item3, out Expr? item4)
		{
			if (list == null) { count = -1; item0 = item1 = item2 = item3 = item4 = default; return; }

			count = 0;

			using var enumerator = list.GetEnumerator();

			if (enumerator.MoveNext())
			{
				count++;
				item0 = enumerator.Current.ToExpr();
	
				if (enumerator.MoveNext())
				{
					count++;
					item1 = enumerator.Current.ToExpr();
		
					if (enumerator.MoveNext())
					{
						count++;
						item2 = enumerator.Current.ToExpr();
			
						if (enumerator.MoveNext())
						{
							count++;
							item3 = enumerator.Current.ToExpr();
				
							if (enumerator.MoveNext())
							{
								count++;
								item4 = enumerator.Current.ToExpr();
					
								switch (list)
								{
									case Expression[]            arr : count = arr.Length; break;
									case ICollection<Expression> col : count = col.Count;  break;
									default : if (enumerator.MoveNext()) count++; break;
								}
							}
							else
							{
								item4 = default;
							}
						}
						else
						{
							item4 = item3 = default;
						}
					}
					else
					{
						item4 = item3 = item2 = default;
					}
				}
				else
				{
					item4 = item3 = item2 = item1 = default;
				}
			}
			else
			{
				item4 = item3 = item2 = item1 = item0 = default;
			}
		}

		public static void Deconstruct(this IEnumerable<Expression> list,
			out int count, out Expr? item0, out Expr? item1, out Expr? item2, out Expr? item3, out Expr? item4, out Expr? item5)
		{
			if (list == null) { count = -1; item0 = item1 = item2 = item3 = item4 = item5 = default; return; }

			count = 0;

			using var enumerator = list.GetEnumerator();

			if (enumerator.MoveNext())
			{
				count++;
				item0 = enumerator.Current.ToExpr();
	
				if (enumerator.MoveNext())
				{
					count++;
					item1 = enumerator.Current.ToExpr();
		
					if (enumerator.MoveNext())
					{
						count++;
						item2 = enumerator.Current.ToExpr();
			
						if (enumerator.MoveNext())
						{
							count++;
							item3 = enumerator.Current.ToExpr();
				
							if (enumerator.MoveNext())
							{
								count++;
								item4 = enumerator.Current.ToExpr();
					
								if (enumerator.MoveNext())
								{
									count++;
									item5 = enumerator.Current.ToExpr();
						
									switch (list)
									{
										case Expression[]            arr : count = arr.Length; break;
										case ICollection<Expression> col : count = col.Count;  break;
										default : if (enumerator.MoveNext()) count++; break;
									}
								}
								else
								{
									item5 = default;
								}
							}
							else
							{
								item5 = item4 = default;
							}
						}
						else
						{
							item5 = item4 = item3 = default;
						}
					}
					else
					{
						item5 = item4 = item3 = item2 = default;
					}
				}
				else
				{
					item5 = item4 = item3 = item2 = item1 = default;
				}
			}
			else
			{
				item5 = item4 = item3 = item2 = item1 = item0 = default;
			}
		}

		public static void Deconstruct(this IEnumerable<Expression> list,
			out int count, out Expr? item0, out Expr? item1, out Expr? item2, out Expr? item3, out Expr? item4, out Expr? item5, out Expr? item6)
		{
			if (list == null) { count = -1; item0 = item1 = item2 = item3 = item4 = item5 = item6 = default; return; }

			count = 0;

			using var enumerator = list.GetEnumerator();

			if (enumerator.MoveNext())
			{
				count++;
				item0 = enumerator.Current.ToExpr();
	
				if (enumerator.MoveNext())
				{
					count++;
					item1 = enumerator.Current.ToExpr();
		
					if (enumerator.MoveNext())
					{
						count++;
						item2 = enumerator.Current.ToExpr();
			
						if (enumerator.MoveNext())
						{
							count++;
							item3 = enumerator.Current.ToExpr();
				
							if (enumerator.MoveNext())
							{
								count++;
								item4 = enumerator.Current.ToExpr();
					
								if (enumerator.MoveNext())
								{
									count++;
									item5 = enumerator.Current.ToExpr();
						
									if (enumerator.MoveNext())
									{
										count++;
										item6 = enumerator.Current.ToExpr();
							
										switch (list)
										{
											case Expression[]            arr : count = arr.Length; break;
											case ICollection<Expression> col : count = col.Count;  break;
											default : if (enumerator.MoveNext()) count++; break;
										}
									}
									else
									{
										item6 = default;
									}
								}
								else
								{
									item6 = item5 = default;
								}
							}
							else
							{
								item6 = item5 = item4 = default;
							}
						}
						else
						{
							item6 = item5 = item4 = item3 = default;
						}
					}
					else
					{
						item6 = item5 = item4 = item3 = item2 = default;
					}
				}
				else
				{
					item6 = item5 = item4 = item3 = item2 = item1 = default;
				}
			}
			else
			{
				item6 = item5 = item4 = item3 = item2 = item1 = item0 = default;
			}
		}

		public static void Deconstruct(this IEnumerable<Expression> list,
			out int count, out Expr? item0, out Expr? item1, out Expr? item2, out Expr? item3, out Expr? item4, out Expr? item5, out Expr? item6, out Expr? item7)
		{
			if (list == null) { count = -1; item0 = item1 = item2 = item3 = item4 = item5 = item6 = item7 = default; return; }

			count = 0;

			using var enumerator = list.GetEnumerator();

			if (enumerator.MoveNext())
			{
				count++;
				item0 = enumerator.Current.ToExpr();
	
				if (enumerator.MoveNext())
				{
					count++;
					item1 = enumerator.Current.ToExpr();
		
					if (enumerator.MoveNext())
					{
						count++;
						item2 = enumerator.Current.ToExpr();
			
						if (enumerator.MoveNext())
						{
							count++;
							item3 = enumerator.Current.ToExpr();
				
							if (enumerator.MoveNext())
							{
								count++;
								item4 = enumerator.Current.ToExpr();
					
								if (enumerator.MoveNext())
								{
									count++;
									item5 = enumerator.Current.ToExpr();
						
									if (enumerator.MoveNext())
									{
										count++;
										item6 = enumerator.Current.ToExpr();
							
										if (enumerator.MoveNext())
										{
											count++;
											item7 = enumerator.Current.ToExpr();
								
											switch (list)
											{
												case Expression[]            arr : count = arr.Length; break;
												case ICollection<Expression> col : count = col.Count;  break;
												default : if (enumerator.MoveNext()) count++; break;
											}
										}
										else
										{
											item7 = default;
										}
									}
									else
									{
										item7 = item6 = default;
									}
								}
								else
								{
									item7 = item6 = item5 = default;
								}
							}
							else
							{
								item7 = item6 = item5 = item4 = default;
							}
						}
						else
						{
							item7 = item6 = item5 = item4 = item3 = default;
						}
					}
					else
					{
						item7 = item6 = item5 = item4 = item3 = item2 = default;
					}
				}
				else
				{
					item7 = item6 = item5 = item4 = item3 = item2 = item1 = default;
				}
			}
			else
			{
				item7 = item6 = item5 = item4 = item3 = item2 = item1 = item0 = default;
			}
		}

		public static void Deconstruct(this IEnumerable<Expression> list,
			out int count, out Expr? item0, out Expr? item1, out Expr? item2, out Expr? item3, out Expr? item4, out Expr? item5, out Expr? item6, out Expr? item7, out Expr? item8)
		{
			if (list == null) { count = -1; item0 = item1 = item2 = item3 = item4 = item5 = item6 = item7 = item8 = default; return; }

			count = 0;

			using var enumerator = list.GetEnumerator();

			if (enumerator.MoveNext())
			{
				count++;
				item0 = enumerator.Current.ToExpr();
	
				if (enumerator.MoveNext())
				{
					count++;
					item1 = enumerator.Current.ToExpr();
		
					if (enumerator.MoveNext())
					{
						count++;
						item2 = enumerator.Current.ToExpr();
			
						if (enumerator.MoveNext())
						{
							count++;
							item3 = enumerator.Current.ToExpr();
				
							if (enumerator.MoveNext())
							{
								count++;
								item4 = enumerator.Current.ToExpr();
					
								if (enumerator.MoveNext())
								{
									count++;
									item5 = enumerator.Current.ToExpr();
						
									if (enumerator.MoveNext())
									{
										count++;
										item6 = enumerator.Current.ToExpr();
							
										if (enumerator.MoveNext())
										{
											count++;
											item7 = enumerator.Current.ToExpr();
								
											if (enumerator.MoveNext())
											{
												count++;
												item8 = enumerator.Current.ToExpr();
									
												switch (list)
												{
													case Expression[]            arr : count = arr.Length; break;
													case ICollection<Expression> col : count = col.Count;  break;
													default : if (enumerator.MoveNext()) count++; break;
												}
											}
											else
											{
												item8 = default;
											}
										}
										else
										{
											item8 = item7 = default;
										}
									}
									else
									{
										item8 = item7 = item6 = default;
									}
								}
								else
								{
									item8 = item7 = item6 = item5 = default;
								}
							}
							else
							{
								item8 = item7 = item6 = item5 = item4 = default;
							}
						}
						else
						{
							item8 = item7 = item6 = item5 = item4 = item3 = default;
						}
					}
					else
					{
						item8 = item7 = item6 = item5 = item4 = item3 = item2 = default;
					}
				}
				else
				{
					item8 = item7 = item6 = item5 = item4 = item3 = item2 = item1 = default;
				}
			}
			else
			{
				item8 = item7 = item6 = item5 = item4 = item3 = item2 = item1 = item0 = default;
			}
		}

		public static void Deconstruct(this IEnumerable<Expression> list,
			out int count, out Expr? item0, out Expr? item1, out Expr? item2, out Expr? item3, out Expr? item4, out Expr? item5, out Expr? item6, out Expr? item7, out Expr? item8, out Expr? item9)
		{
			if (list == null) { count = -1; item0 = item1 = item2 = item3 = item4 = item5 = item6 = item7 = item8 = item9 = default; return; }

			count = 0;

			using var enumerator = list.GetEnumerator();

			if (enumerator.MoveNext())
			{
				count++;
				item0 = enumerator.Current.ToExpr();
	
				if (enumerator.MoveNext())
				{
					count++;
					item1 = enumerator.Current.ToExpr();
		
					if (enumerator.MoveNext())
					{
						count++;
						item2 = enumerator.Current.ToExpr();
			
						if (enumerator.MoveNext())
						{
							count++;
							item3 = enumerator.Current.ToExpr();
				
							if (enumerator.MoveNext())
							{
								count++;
								item4 = enumerator.Current.ToExpr();
					
								if (enumerator.MoveNext())
								{
									count++;
									item5 = enumerator.Current.ToExpr();
						
									if (enumerator.MoveNext())
									{
										count++;
										item6 = enumerator.Current.ToExpr();
							
										if (enumerator.MoveNext())
										{
											count++;
											item7 = enumerator.Current.ToExpr();
								
											if (enumerator.MoveNext())
											{
												count++;
												item8 = enumerator.Current.ToExpr();
									
												if (enumerator.MoveNext())
												{
													count++;
													item9 = enumerator.Current.ToExpr();
										
													switch (list)
													{
														case Expression[]            arr : count = arr.Length; break;
														case ICollection<Expression> col : count = col.Count;  break;
														default : if (enumerator.MoveNext()) count++; break;
													}
												}
												else
												{
													item9 = default;
												}
											}
											else
											{
												item9 = item8 = default;
											}
										}
										else
										{
											item9 = item8 = item7 = default;
										}
									}
									else
									{
										item9 = item8 = item7 = item6 = default;
									}
								}
								else
								{
									item9 = item8 = item7 = item6 = item5 = default;
								}
							}
							else
							{
								item9 = item8 = item7 = item6 = item5 = item4 = default;
							}
						}
						else
						{
							item9 = item8 = item7 = item6 = item5 = item4 = item3 = default;
						}
					}
					else
					{
						item9 = item8 = item7 = item6 = item5 = item4 = item3 = item2 = default;
					}
				}
				else
				{
					item9 = item8 = item7 = item6 = item5 = item4 = item3 = item2 = item1 = default;
				}
			}
			else
			{
				item9 = item8 = item7 = item6 = item5 = item4 = item3 = item2 = item1 = item0 = default;
			}
		}

		#endregion

		#region IEnumerable<ParameterExpression>

		public static void Deconstruct(this IEnumerable<ParameterExpression> list, out int count)
		{
			switch (list)
			{
				case ParameterExpression[]            arr : count = arr.Length; break;
				case ICollection<ParameterExpression> col : count = col.Count;  break;
				case null : count = -1; break;
				default   :
					using (var enumerator = list.GetEnumerator())
						count = enumerator.MoveNext() ? 1 : 0;
					break;
			}
		}

		public static void Deconstruct(this IEnumerable<ParameterExpression> list,
			out int count, out Expr.Parameter? item0)
		{
			if (list == null) { count = -1; item0 = default; return; }

			count = 0;

			using var enumerator = list.GetEnumerator();

			if (enumerator.MoveNext())
			{
				count++;
				item0 = new Expr.Parameter(enumerator.Current);
	
				switch (list)
				{
					case ParameterExpression[]            arr : count = arr.Length; break;
					case ICollection<ParameterExpression> col : count = col.Count;  break;
					default : if (enumerator.MoveNext()) count++; break;
				}
			}
			else
			{
				item0 = default;
			}
		}

		public static void Deconstruct(this IEnumerable<ParameterExpression> list,
			out int count, out Expr.Parameter? item0, out Expr.Parameter? item1)
		{
			if (list == null) { count = -1; item0 = item1 = default; return; }

			count = 0;

			using var enumerator = list.GetEnumerator();

			if (enumerator.MoveNext())
			{
				count++;
				item0 = new Expr.Parameter(enumerator.Current);
	
				if (enumerator.MoveNext())
				{
					count++;
					item1 = new Expr.Parameter(enumerator.Current);
		
					switch (list)
					{
						case ParameterExpression[]            arr : count = arr.Length; break;
						case ICollection<ParameterExpression> col : count = col.Count;  break;
						default : if (enumerator.MoveNext()) count++; break;
					}
				}
				else
				{
					item1 = default;
				}
			}
			else
			{
				item1 = item0 = default;
			}
		}

		public static void Deconstruct(this IEnumerable<ParameterExpression> list,
			out int count, out Expr.Parameter? item0, out Expr.Parameter? item1, out Expr.Parameter? item2)
		{
			if (list == null) { count = -1; item0 = item1 = item2 = default; return; }

			count = 0;

			using var enumerator = list.GetEnumerator();

			if (enumerator.MoveNext())
			{
				count++;
				item0 = new Expr.Parameter(enumerator.Current);
	
				if (enumerator.MoveNext())
				{
					count++;
					item1 = new Expr.Parameter(enumerator.Current);
		
					if (enumerator.MoveNext())
					{
						count++;
						item2 = new Expr.Parameter(enumerator.Current);
			
						switch (list)
						{
							case ParameterExpression[]            arr : count = arr.Length; break;
							case ICollection<ParameterExpression> col : count = col.Count;  break;
							default : if (enumerator.MoveNext()) count++; break;
						}
					}
					else
					{
						item2 = default;
					}
				}
				else
				{
					item2 = item1 = default;
				}
			}
			else
			{
				item2 = item1 = item0 = default;
			}
		}

		public static void Deconstruct(this IEnumerable<ParameterExpression> list,
			out int count, out Expr.Parameter? item0, out Expr.Parameter? item1, out Expr.Parameter? item2, out Expr.Parameter? item3)
		{
			if (list == null) { count = -1; item0 = item1 = item2 = item3 = default; return; }

			count = 0;

			using var enumerator = list.GetEnumerator();

			if (enumerator.MoveNext())
			{
				count++;
				item0 = new Expr.Parameter(enumerator.Current);
	
				if (enumerator.MoveNext())
				{
					count++;
					item1 = new Expr.Parameter(enumerator.Current);
		
					if (enumerator.MoveNext())
					{
						count++;
						item2 = new Expr.Parameter(enumerator.Current);
			
						if (enumerator.MoveNext())
						{
							count++;
							item3 = new Expr.Parameter(enumerator.Current);
				
							switch (list)
							{
								case ParameterExpression[]            arr : count = arr.Length; break;
								case ICollection<ParameterExpression> col : count = col.Count;  break;
								default : if (enumerator.MoveNext()) count++; break;
							}
						}
						else
						{
							item3 = default;
						}
					}
					else
					{
						item3 = item2 = default;
					}
				}
				else
				{
					item3 = item2 = item1 = default;
				}
			}
			else
			{
				item3 = item2 = item1 = item0 = default;
			}
		}

		public static void Deconstruct(this IEnumerable<ParameterExpression> list,
			out int count, out Expr.Parameter? item0, out Expr.Parameter? item1, out Expr.Parameter? item2, out Expr.Parameter? item3, out Expr.Parameter? item4)
		{
			if (list == null) { count = -1; item0 = item1 = item2 = item3 = item4 = default; return; }

			count = 0;

			using var enumerator = list.GetEnumerator();

			if (enumerator.MoveNext())
			{
				count++;
				item0 = new Expr.Parameter(enumerator.Current);
	
				if (enumerator.MoveNext())
				{
					count++;
					item1 = new Expr.Parameter(enumerator.Current);
		
					if (enumerator.MoveNext())
					{
						count++;
						item2 = new Expr.Parameter(enumerator.Current);
			
						if (enumerator.MoveNext())
						{
							count++;
							item3 = new Expr.Parameter(enumerator.Current);
				
							if (enumerator.MoveNext())
							{
								count++;
								item4 = new Expr.Parameter(enumerator.Current);
					
								switch (list)
								{
									case ParameterExpression[]            arr : count = arr.Length; break;
									case ICollection<ParameterExpression> col : count = col.Count;  break;
									default : if (enumerator.MoveNext()) count++; break;
								}
							}
							else
							{
								item4 = default;
							}
						}
						else
						{
							item4 = item3 = default;
						}
					}
					else
					{
						item4 = item3 = item2 = default;
					}
				}
				else
				{
					item4 = item3 = item2 = item1 = default;
				}
			}
			else
			{
				item4 = item3 = item2 = item1 = item0 = default;
			}
		}

		public static void Deconstruct(this IEnumerable<ParameterExpression> list,
			out int count, out Expr.Parameter? item0, out Expr.Parameter? item1, out Expr.Parameter? item2, out Expr.Parameter? item3, out Expr.Parameter? item4, out Expr.Parameter? item5)
		{
			if (list == null) { count = -1; item0 = item1 = item2 = item3 = item4 = item5 = default; return; }

			count = 0;

			using var enumerator = list.GetEnumerator();

			if (enumerator.MoveNext())
			{
				count++;
				item0 = new Expr.Parameter(enumerator.Current);
	
				if (enumerator.MoveNext())
				{
					count++;
					item1 = new Expr.Parameter(enumerator.Current);
		
					if (enumerator.MoveNext())
					{
						count++;
						item2 = new Expr.Parameter(enumerator.Current);
			
						if (enumerator.MoveNext())
						{
							count++;
							item3 = new Expr.Parameter(enumerator.Current);
				
							if (enumerator.MoveNext())
							{
								count++;
								item4 = new Expr.Parameter(enumerator.Current);
					
								if (enumerator.MoveNext())
								{
									count++;
									item5 = new Expr.Parameter(enumerator.Current);
						
									switch (list)
									{
										case ParameterExpression[]            arr : count = arr.Length; break;
										case ICollection<ParameterExpression> col : count = col.Count;  break;
										default : if (enumerator.MoveNext()) count++; break;
									}
								}
								else
								{
									item5 = default;
								}
							}
							else
							{
								item5 = item4 = default;
							}
						}
						else
						{
							item5 = item4 = item3 = default;
						}
					}
					else
					{
						item5 = item4 = item3 = item2 = default;
					}
				}
				else
				{
					item5 = item4 = item3 = item2 = item1 = default;
				}
			}
			else
			{
				item5 = item4 = item3 = item2 = item1 = item0 = default;
			}
		}

		public static void Deconstruct(this IEnumerable<ParameterExpression> list,
			out int count, out Expr.Parameter? item0, out Expr.Parameter? item1, out Expr.Parameter? item2, out Expr.Parameter? item3, out Expr.Parameter? item4, out Expr.Parameter? item5, out Expr.Parameter? item6)
		{
			if (list == null) { count = -1; item0 = item1 = item2 = item3 = item4 = item5 = item6 = default; return; }

			count = 0;

			using var enumerator = list.GetEnumerator();

			if (enumerator.MoveNext())
			{
				count++;
				item0 = new Expr.Parameter(enumerator.Current);
	
				if (enumerator.MoveNext())
				{
					count++;
					item1 = new Expr.Parameter(enumerator.Current);
		
					if (enumerator.MoveNext())
					{
						count++;
						item2 = new Expr.Parameter(enumerator.Current);
			
						if (enumerator.MoveNext())
						{
							count++;
							item3 = new Expr.Parameter(enumerator.Current);
				
							if (enumerator.MoveNext())
							{
								count++;
								item4 = new Expr.Parameter(enumerator.Current);
					
								if (enumerator.MoveNext())
								{
									count++;
									item5 = new Expr.Parameter(enumerator.Current);
						
									if (enumerator.MoveNext())
									{
										count++;
										item6 = new Expr.Parameter(enumerator.Current);
							
										switch (list)
										{
											case ParameterExpression[]            arr : count = arr.Length; break;
											case ICollection<ParameterExpression> col : count = col.Count;  break;
											default : if (enumerator.MoveNext()) count++; break;
										}
									}
									else
									{
										item6 = default;
									}
								}
								else
								{
									item6 = item5 = default;
								}
							}
							else
							{
								item6 = item5 = item4 = default;
							}
						}
						else
						{
							item6 = item5 = item4 = item3 = default;
						}
					}
					else
					{
						item6 = item5 = item4 = item3 = item2 = default;
					}
				}
				else
				{
					item6 = item5 = item4 = item3 = item2 = item1 = default;
				}
			}
			else
			{
				item6 = item5 = item4 = item3 = item2 = item1 = item0 = default;
			}
		}

		public static void Deconstruct(this IEnumerable<ParameterExpression> list,
			out int count, out Expr.Parameter? item0, out Expr.Parameter? item1, out Expr.Parameter? item2, out Expr.Parameter? item3, out Expr.Parameter? item4, out Expr.Parameter? item5, out Expr.Parameter? item6, out Expr.Parameter? item7)
		{
			if (list == null) { count = -1; item0 = item1 = item2 = item3 = item4 = item5 = item6 = item7 = default; return; }

			count = 0;

			using var enumerator = list.GetEnumerator();

			if (enumerator.MoveNext())
			{
				count++;
				item0 = new Expr.Parameter(enumerator.Current);
	
				if (enumerator.MoveNext())
				{
					count++;
					item1 = new Expr.Parameter(enumerator.Current);
		
					if (enumerator.MoveNext())
					{
						count++;
						item2 = new Expr.Parameter(enumerator.Current);
			
						if (enumerator.MoveNext())
						{
							count++;
							item3 = new Expr.Parameter(enumerator.Current);
				
							if (enumerator.MoveNext())
							{
								count++;
								item4 = new Expr.Parameter(enumerator.Current);
					
								if (enumerator.MoveNext())
								{
									count++;
									item5 = new Expr.Parameter(enumerator.Current);
						
									if (enumerator.MoveNext())
									{
										count++;
										item6 = new Expr.Parameter(enumerator.Current);
							
										if (enumerator.MoveNext())
										{
											count++;
											item7 = new Expr.Parameter(enumerator.Current);
								
											switch (list)
											{
												case ParameterExpression[]            arr : count = arr.Length; break;
												case ICollection<ParameterExpression> col : count = col.Count;  break;
												default : if (enumerator.MoveNext()) count++; break;
											}
										}
										else
										{
											item7 = default;
										}
									}
									else
									{
										item7 = item6 = default;
									}
								}
								else
								{
									item7 = item6 = item5 = default;
								}
							}
							else
							{
								item7 = item6 = item5 = item4 = default;
							}
						}
						else
						{
							item7 = item6 = item5 = item4 = item3 = default;
						}
					}
					else
					{
						item7 = item6 = item5 = item4 = item3 = item2 = default;
					}
				}
				else
				{
					item7 = item6 = item5 = item4 = item3 = item2 = item1 = default;
				}
			}
			else
			{
				item7 = item6 = item5 = item4 = item3 = item2 = item1 = item0 = default;
			}
		}

		public static void Deconstruct(this IEnumerable<ParameterExpression> list,
			out int count, out Expr.Parameter? item0, out Expr.Parameter? item1, out Expr.Parameter? item2, out Expr.Parameter? item3, out Expr.Parameter? item4, out Expr.Parameter? item5, out Expr.Parameter? item6, out Expr.Parameter? item7, out Expr.Parameter? item8)
		{
			if (list == null) { count = -1; item0 = item1 = item2 = item3 = item4 = item5 = item6 = item7 = item8 = default; return; }

			count = 0;

			using var enumerator = list.GetEnumerator();

			if (enumerator.MoveNext())
			{
				count++;
				item0 = new Expr.Parameter(enumerator.Current);
	
				if (enumerator.MoveNext())
				{
					count++;
					item1 = new Expr.Parameter(enumerator.Current);
		
					if (enumerator.MoveNext())
					{
						count++;
						item2 = new Expr.Parameter(enumerator.Current);
			
						if (enumerator.MoveNext())
						{
							count++;
							item3 = new Expr.Parameter(enumerator.Current);
				
							if (enumerator.MoveNext())
							{
								count++;
								item4 = new Expr.Parameter(enumerator.Current);
					
								if (enumerator.MoveNext())
								{
									count++;
									item5 = new Expr.Parameter(enumerator.Current);
						
									if (enumerator.MoveNext())
									{
										count++;
										item6 = new Expr.Parameter(enumerator.Current);
							
										if (enumerator.MoveNext())
										{
											count++;
											item7 = new Expr.Parameter(enumerator.Current);
								
											if (enumerator.MoveNext())
											{
												count++;
												item8 = new Expr.Parameter(enumerator.Current);
									
												switch (list)
												{
													case ParameterExpression[]            arr : count = arr.Length; break;
													case ICollection<ParameterExpression> col : count = col.Count;  break;
													default : if (enumerator.MoveNext()) count++; break;
												}
											}
											else
											{
												item8 = default;
											}
										}
										else
										{
											item8 = item7 = default;
										}
									}
									else
									{
										item8 = item7 = item6 = default;
									}
								}
								else
								{
									item8 = item7 = item6 = item5 = default;
								}
							}
							else
							{
								item8 = item7 = item6 = item5 = item4 = default;
							}
						}
						else
						{
							item8 = item7 = item6 = item5 = item4 = item3 = default;
						}
					}
					else
					{
						item8 = item7 = item6 = item5 = item4 = item3 = item2 = default;
					}
				}
				else
				{
					item8 = item7 = item6 = item5 = item4 = item3 = item2 = item1 = default;
				}
			}
			else
			{
				item8 = item7 = item6 = item5 = item4 = item3 = item2 = item1 = item0 = default;
			}
		}

		public static void Deconstruct(this IEnumerable<ParameterExpression> list,
			out int count, out Expr.Parameter? item0, out Expr.Parameter? item1, out Expr.Parameter? item2, out Expr.Parameter? item3, out Expr.Parameter? item4, out Expr.Parameter? item5, out Expr.Parameter? item6, out Expr.Parameter? item7, out Expr.Parameter? item8, out Expr.Parameter? item9)
		{
			if (list == null) { count = -1; item0 = item1 = item2 = item3 = item4 = item5 = item6 = item7 = item8 = item9 = default; return; }

			count = 0;

			using var enumerator = list.GetEnumerator();

			if (enumerator.MoveNext())
			{
				count++;
				item0 = new Expr.Parameter(enumerator.Current);
	
				if (enumerator.MoveNext())
				{
					count++;
					item1 = new Expr.Parameter(enumerator.Current);
		
					if (enumerator.MoveNext())
					{
						count++;
						item2 = new Expr.Parameter(enumerator.Current);
			
						if (enumerator.MoveNext())
						{
							count++;
							item3 = new Expr.Parameter(enumerator.Current);
				
							if (enumerator.MoveNext())
							{
								count++;
								item4 = new Expr.Parameter(enumerator.Current);
					
								if (enumerator.MoveNext())
								{
									count++;
									item5 = new Expr.Parameter(enumerator.Current);
						
									if (enumerator.MoveNext())
									{
										count++;
										item6 = new Expr.Parameter(enumerator.Current);
							
										if (enumerator.MoveNext())
										{
											count++;
											item7 = new Expr.Parameter(enumerator.Current);
								
											if (enumerator.MoveNext())
											{
												count++;
												item8 = new Expr.Parameter(enumerator.Current);
									
												if (enumerator.MoveNext())
												{
													count++;
													item9 = new Expr.Parameter(enumerator.Current);
										
													switch (list)
													{
														case ParameterExpression[]            arr : count = arr.Length; break;
														case ICollection<ParameterExpression> col : count = col.Count;  break;
														default : if (enumerator.MoveNext()) count++; break;
													}
												}
												else
												{
													item9 = default;
												}
											}
											else
											{
												item9 = item8 = default;
											}
										}
										else
										{
											item9 = item8 = item7 = default;
										}
									}
									else
									{
										item9 = item8 = item7 = item6 = default;
									}
								}
								else
								{
									item9 = item8 = item7 = item6 = item5 = default;
								}
							}
							else
							{
								item9 = item8 = item7 = item6 = item5 = item4 = default;
							}
						}
						else
						{
							item9 = item8 = item7 = item6 = item5 = item4 = item3 = default;
						}
					}
					else
					{
						item9 = item8 = item7 = item6 = item5 = item4 = item3 = item2 = default;
					}
				}
				else
				{
					item9 = item8 = item7 = item6 = item5 = item4 = item3 = item2 = item1 = default;
				}
			}
			else
			{
				item9 = item8 = item7 = item6 = item5 = item4 = item3 = item2 = item1 = item0 = default;
			}
		}

		#endregion

	}
}
