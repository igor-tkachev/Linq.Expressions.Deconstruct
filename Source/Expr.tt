<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension=".generated.cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
//---------------------------------------------------------------------------------------------------
// <auto-generated>
//    This code was generated by T4 template.
//    Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>
//---------------------------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq.Expressions;
using System.Reflection;

#nullable enable

namespace Linq.Expressions.Deconstruct
{
	public abstract partial class Expr
	{
<#
	foreach (var item in new []
	{
		new { Expression = "MethodCallExpression",       Expr = "Call"              },
		new { Expression = "ConditionalExpression",      Expr = "Conditional",      },
		new { Expression = "InvocationExpression",       Expr = "Invoke",           },
		new { Expression = "LambdaExpression",           Expr = "Lambda",           },
		new { Expression = "ListInitExpression",         Expr = "ListInit",         },
		new { Expression = "MemberExpression",           Expr = "Member",           },
		new { Expression = "MemberInitExpression",       Expr = "MemberInit",       },
		new { Expression = "NewExpression",              Expr = "New",              },
		new { Expression = "NewArrayExpression",         Expr = "NewArrayBounds",   },
		new { Expression = "NewArrayExpression",         Expr = "NewArrayInit",     },
		new { Expression = "TypeBinaryExpression",       Expr = "TypeEqual",        },
		new { Expression = "TypeBinaryExpression",       Expr = "TypeIs",           },
		new { Expression = "BlockExpression",            Expr = "Block",            },
		new { Expression = "DynamicExpression",          Expr = "Dynamic",          },
		new { Expression = "GotoExpression",             Expr = "Goto",             },
		new { Expression = "IndexExpression",            Expr = "Index",            },
		new { Expression = "LabelExpression",            Expr = "Label",            },
		new { Expression = "RuntimeVariablesExpression", Expr = "RuntimeVariables", },
		new { Expression = "LoopExpression",             Expr = "Loop",             },
		new { Expression = "SwitchExpression",           Expr = "Switch",           },
		new { Expression = "TryExpression",              Expr = "Try",              },
		new { Expression = "Expression",                 Expr = "Extension",        },
		new { Expression = "DebugInfoExpression",        Expr = "DebugInfo",        },
		new { Expression = "ParameterExpression",        Expr = "Parameter",        },
		new { Expression = "ConstantExpression",         Expr = "Constant",         },
		new { Expression = "DefaultExpression",          Expr = "Default",          },
	})
	{
#>
		#region <#= item.Expr #>

		public partial class <#= item.Expr #> : Expr
		{
			public <#= item.Expression #> Expr { get; }

			public <#= item.Expr #>(<#= item.Expression #> expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

<#
		if (item.Expression != "Expression")
		{
#>
			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?(<#= item.Expr #>? expr) => expr?.Expr;

<#
		}
#>
			[return: NotNullIfNotNull("expr")]
			public static implicit operator <#= item.Expression #>?(<#= item.Expr #>? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator <#= item.Expr #>?(<#= item.Expression #>? expr) => expr == null ? null : new <#= item.Expr #>(expr);
		}

		#endregion

<#
	}

	foreach (var item in new []
	{
		"Add", "AddChecked", "And", "AndAlso", "ArrayIndex",
		"Assign", "Coalesce", "Divide", "Equal", "ExclusiveOr",
		"GreaterThan", "GreaterThanOrEqual", "LeftShift", "LessThan", "LessThanOrEqual",
		"Modulo", "Multiply", "MultiplyChecked", "NotEqual", "Or",
		"OrElse", "Power", "RightShift", "Subtract", "SubtractChecked",
		"AddAssign", "AndAssign", "DivideAssign", "ExclusiveOrAssign", "LeftShiftAssign",
		"ModuloAssign", "MultiplyAssign", "OrAssign", "PowerAssign", "RightShiftAssign",
		"SubtractAssign", "AddAssignChecked", "MultiplyAssignChecked", "SubtractAssignChecked",
	})
	{
#>
		#region <#= item #>

		public class <#= item #> : Expr
		{
			public BinaryExpression Expr { get; }

			public <#= item #>(BinaryExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?      (<#= item #>? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator BinaryExpression?(<#= item #>? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator <#= item #>?(BinaryExpression? expr) => expr == null ? null : new <#= item #>(expr);

			public void Deconstruct(out Type type, out Expr left, out Expr right)
			{
				type  = Expr.Type;
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}

			public void Deconstruct(out Expr left, out Expr right)
			{
				left  = Expr.Left. ToExpr();
				right = Expr.Right.ToExpr();
			}
		}

		#endregion

<#
	}

	foreach (var item in new []
	{
		"ArrayLength", "Convert", "ConvertChecked", "Negate", "NegateChecked",
		"Not", "Quote", "TypeAs", "UnaryPlus", "Decrement",
		"Increment", "IsFalse", "IsTrue", "Throw", "Unbox",
		"PreIncrementAssign", "PreDecrementAssign", "PostIncrementAssign", "PostDecrementAssign", "OnesComplement",
	})
	{
#>
		#region <#= item #>

		public class <#= item #> : Expr
		{
			public UnaryExpression Expr { get; }

			public <#= item #>(UnaryExpression expr)
			{
				Expr = expr;
			}

			protected override Expression GetExpression() => Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator Expression?     (<#= item #>? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator UnaryExpression?(<#= item #>? expr) => expr?.Expr;

			[return: NotNullIfNotNull("expr")]
			public static implicit operator <#= item #>?(UnaryExpression? expr) => expr == null ? null : new <#= item #>(expr);

			public void Deconstruct(out Type type, out Expr? operand)
			{
				type    = Expr.Type;
				operand = Expr.Operand.ToExpr();
			}

			public void Deconstruct(out Expr? operand)
			{
				operand = Expr.Operand.ToExpr();
			}
		}

		#endregion

<#
	}

#>
	}

	public static partial class Extensions
	{
<#

	foreach (var item in new[]
	{
		new { TItem = "ElementInit",         PItem = "ElementInit",    BConvert = "", AConvert = "" },
		new { TItem = "CatchBlock",          PItem = "CatchBlock",     BConvert = "", AConvert = "" },
		new { TItem = "SwitchCase",          PItem = "SwitchCase",     BConvert = "", AConvert = "" },
		new { TItem = "MemberBinding",       PItem = "MemberBinding",  BConvert = "", AConvert = "" },
		new { TItem = "MemberInfo",          PItem = "MemberInfo",     BConvert = "", AConvert = "" },
		new { TItem = "Expression",          PItem = "Expr",           BConvert = "", AConvert = ".ToExpr()" },
		new { TItem = "ParameterExpression", PItem = "Expr.Parameter", BConvert = "new Expr.Parameter(", AConvert = ")" },

		new { TItem = "Expr",                PItem = "Expr",           BConvert = "", AConvert = "" },
		new { TItem = "Expr.Parameter",      PItem = "Expr.Parameter", BConvert = "", AConvert = "" },
	})
	{
		var max = 10;

#>
		#region IEnumerable<<#= item.TItem #>>

		public static void Deconstruct(this IEnumerable<<#= item.TItem #>> list, out int count)
		{
			switch (list)
			{
				case <#= item.TItem #>[]            arr : count = arr.Length; break;
				case ICollection<<#= item.TItem #>> col : count = col.Count;  break;
				case null : count = -1; break;
				default   :
					using (var enumerator = list.GetEnumerator())
						count = enumerator.MoveNext() ? 1 : 0;
					break;
			}
		}

<#

		for (var i = 0; i < max; i++)
		{
#>
		public static void Deconstruct(this IEnumerable<<#= item.TItem #>> list,
			out int count<#

			for (var j = 0; j <= i; j++)
			{
				#>, out <#= item.PItem #>? item<#= j #><#
			}

			#>)
		{
			if (list == null) { count = -1; <#
			for (var j = 0; j <= i; j++)
			{
				#>item<#= j #> = <#
			}
				#>default; return; }

			count = 0;

			using var enumerator = list.GetEnumerator();
<#
			for (var j = 0; j <= i; j++)
			{
#>

			if (enumerator.MoveNext())
			{
				count++;
				item<#= j #> = <#= item.BConvert #>enumerator.Current<#= item.AConvert #>;
<#
				PushIndent("\t");
			}

#>

			switch (list)
			{
				case <#= item.TItem #>[]            arr : count = arr.Length; break;
				case ICollection<<#= item.TItem #>> col : count = col.Count;  break;
				default : if (enumerator.MoveNext()) count++; break;
			}<#

			for (var j = 0; j <= i; j++)
			{
				PopIndent();
#>

			}
			else
			{
				<#
				for (var k = 0; k <= j; k++)
				{
					#>item<#= i - k #> = <#
				}
				#>default;
			}<#
			}
#>

		}

<#
		}
#>
		#endregion

<#

	}
#>
	}
}
